---
title: 图的应用
tags:
  - "#图的应用"
  - "#最小生成树"
  - "#prim算法"
  - "#Kruskal算法"
  - "#最短路径"
  - "#Dijkstra算法"
  - "#Floyd算法"
  - "#有向无环图"
  - "#拓扑排序"
  - "#关键路径"
date: 2026-02-27
---
---

### 最小生成树

#### 定义

一个连通图的生成树包含了图的所有顶点，并且仅包含尽可能少的边。  
对生成树来说，若移除一条边，则会使该生成树变成非连通图；  
若增加一条边，则会在图中形成一条回路。

对于带权连通无向图 $G$ 而言，不同的生成树其总权重（树中所有边的权值之和）可能不同。**具有最小总权重的生成树称为图 $G$ 的最小生成树**（Minimum-Spanning-Tree，**MST**）。

#### 最小生成树的特性

1. **若图 $G$ 中含有权值相同的边，则最小生成树可能不唯一**，即可能存在多个不同的最小生成树。  
   **当图 $G$ 中所有边的权值互不相同时，最小生成树是唯一的**。此外，若无向连通图 $G$ 本身的边数等于顶点数减 1（$G$ 本身就是一棵树），则其最小生成树就是它本身。

2. 虽然最小生成树可能不唯一，但**所有最小生成树的总权重都是相同的**，且为最小值。

3. **最小生成树的边数等于顶点数减 1。**
#### 注意·
![](assets/图的应用/file-20260227181024730.png)
#### 构造最小生成树的方法

构造最小生成树的方法有多种，但大多数算法都基于这样一个**核心性质**：  
假设 $G=(V,E)$ 是一个带权连通无向图，$U$ 是顶点集 $V$ 的一个非空子集。若 $(u,v)$ 是一条权值最小的边，其中 $u\in U$，$v\in V-U$，则图 $G$ 中必存在一棵包含边 $(u,v)$ 的最小生成树。

基于此原理的主要算法包括**Prim 算法和 Kruskal 算法**，二者均采用**贪心策略**。

#### 最小生成树通用算法框架：

```text
GENERIC_MST(G) {
    T=NULL;
    while T 未形成一棵生成树;
        do 找到一条最小代价边(u,v)并且加入T后不会产生回路;
            T=T∪(u,v);
}
```

**通过逐步添加边来逐渐构造一棵生成树**，下面介绍实现上述框架的两种经典算法。


#### Prim 算法

Prim（普里姆）算法在执行过程上与求解单源最短路径的 Dijkstra 算法较为相似。

##### 算法思想

初始时，从图中任取一个顶点加入树 $T$，此时 $T$ 仅包含该顶点。接着，选择一个与当前 $T$ 中顶点集合距离最近的顶点，并将该顶点及其相连的最小权值边加入 $T$。每执行一次此操作，$T$ 中的顶点数和边数各增加 1。重复这一过程，直到图中所有顶点都被并入 $T$ 为止。最终得到的 $T$ 即为最小生成树，且其中必然含有 $n-1$ 条边。图 6.15 展示了 Prim 算法构造最小生成树的过程。
![](assets/图的应用/file-20260227185115511.png)

##### Prim 算法步骤

- 假设 $G={V,E}$ 是连通图，其最小生成树 $T=(U,E_T)$，$E_T$ 是 $T$ 中的边集合。

- 初始化：向空树 $T=(U,E_T)$ 中添加图 $G$ 的任意一个顶点 $u_0$，使得 $U={u_0}$，$E_T=\varnothing$。

- 循环（重复，直至 $U=V$）：从图 $G$ 中选择满足条件 ${(u,v)\mid u\in U,\ v\in V-U}$ 且具有最小权值的边 $(u,v)$，将其加入树 $T$，并更新 $U=U\cup{v}$，$E_T=E_T\cup{(u,v)}$。

##### Prim 算法的简单代码实现

```text
void Prim(G,T){
    T=∅;                 //初始化空树
    U={w};               //添加任意一个顶点w
    while((V-U)!=∅){     //若树中不含全部顶点
        设(u,v)是使u∈U 与 v∈(V-U)，且权值最小的边;
        T=T∪{(u,v)};     //边归入树
        U=U∪{v};         //顶点归入树
    }
}
```

##### 时间复杂度分析

在 Prim 算法中，每步都从当前已构建的树向外扩展一条最短边，逐步生长出整棵最小生成树。  
该算法的时间复杂度为 $O(|V|^2)$，与边数 $|E|$ 无关，因此特别适用于求解**边稠密**图的最小生成树。  
虽然采用其他方法能改进 Prim 算法的时间复杂度，但会增加实现的复杂度。



#### Kruskal 算法


与 Prim 算法从一个顶点开始扩展最小生成树的方式不同，Kruskal（克鲁斯卡尔）算法采用按边的权值递增次序选择合适的边来构造最小生成树的方法。

##### 算法思想

初始时，图 $T={V,{}}$ 包含全部 $n$ 个顶点，但不含任何边，每个顶点自成一个连通分量。  
然后按照边的权值从小到大的顺序，依次考察各条边：  
如果当前边连接的两个顶点属于 $T$ 中不同的连通分量（可通过并查集判断），则将该边加入 $T$；  
否则，舍弃此边，继续考察下一条权值最小的边。  
重复这一过程，直到所有顶点都属于同一个连通分量，此时得到的 $T$ 即为最小生成树。图 6.16 展示了 Kruskal 算法构造最小生成树的过程。
![](assets/图的应用/file-20260227185050526.png)

##### Kruskal 算法步骤

- 假设 $G=(V,E)$ 是连通图，其最小生成树 $T=(U,E_T)$，$E_T$ 是 $T$ 中的边集合。

- 初始化：$U=V$，$E_T=\varnothing$。即每个顶点构成一棵独立的树，$T$ 此时是一个仅含 $|V|$ 个顶点的森林。

- 循环（重复，直至 $T$ 成为一棵树）：按照边权值递增的顺序，从 $E-E_T$ 中选择一条边。若该边加入 $T$ 后不构成回路，则将其加入 $E_T$；否则舍弃，直到 $E_T$ 包含 $n-1$ 条边为止。


##### Kruskal 算法的简单代码实现

```text
void Kruskal(V,T){
    T=V;                         //初始化树T，仅含顶点
    numS=n;                      //连通分量数
    while(numS>1){               //若连通分量数大于1
        从E中取出权值最小的边(v,u);
        if(v 和 u 属于T中不同的连通分量){
            T=T∪{(v,u)};         //将此边加入生成树中
            numS--;              //连通分量数减1
        }
    }
}
```

##### 时间复杂度分析

在 Kruskal 算法中，每当选择一条连接两棵不同树的边时，这两棵树将通过这条边合并为一棵更大的树，随着算法的进行，整个森林逐渐合并成一棵树。  
考虑到算法效率，在最坏情况下需要对所有的 $|E|$ 条边各扫描一次。  
通常，边会存储在一个堆（见第 7 章）中，每次从中选出最小权值的边所需时间为 $O(\log_2|E|)$。  
同时，使用**并查集**来快速确定两个顶点是否属于同一集合的时间复杂度为 $O(\alpha(|V|))$，这里 $\alpha(|V|)$ 增长极其缓慢，可视为常数。  
因此，Kruskal 算法的总时间复杂度为 $O(|E|\log_2|E|)$，不依赖于 $|V|$，这使得它特别适合于处理**边稀疏但顶点较多**的图。
[[并查集]]


### 最短路径

