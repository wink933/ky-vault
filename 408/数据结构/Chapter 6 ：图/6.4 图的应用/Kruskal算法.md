---
title: Kruskal算法
tags:
  - "#Kruskal算法"
date: 2026-02-28
---
---

#### Kruskal 算法


与 Prim 算法从一个顶点开始扩展最小生成树的方式不同，Kruskal（克鲁斯卡尔）算法采用按边的权值递增次序选择合适的边来构造最小生成树的方法。

##### 算法思想

初始时，图 $T={V,{}}$ 包含全部 $n$ 个顶点，但不含任何边，每个顶点自成一个连通分量。  
然后按照边的权值从小到大的顺序，依次考察各条边：  
如果当前边连接的两个顶点属于 $T$ 中不同的连通分量（可通过并查集判断），则将该边加入 $T$；  
否则，舍弃此边，继续考察下一条权值最小的边。  
重复这一过程，直到所有顶点都属于同一个连通分量，此时得到的 $T$ 即为最小生成树。图 6.16 展示了 Kruskal 算法构造最小生成树的过程。
![](file-20260228231426011.png)

##### Kruskal 算法步骤

- 假设 $G=(V,E)$ 是连通图，其最小生成树 $T=(U,E_T)$，$E_T$ 是 $T$ 中的边集合。

- 初始化：$U=V$，$E_T=\varnothing$。即每个顶点构成一棵独立的树，$T$ 此时是一个仅含 $|V|$ 个顶点的森林。

- 循环（重复，直至 $T$ 成为一棵树）：按照边权值递增的顺序，从 $E-E_T$ 中选择一条边。若该边加入 $T$ 后不构成回路，则将其加入 $E_T$；否则舍弃，直到 $E_T$ 包含 $n-1$ 条边为止。


##### Kruskal 算法的简单代码实现

```text
void Kruskal(V,T){
    T=V;                         //初始化树T，仅含顶点
    numS=n;                      //连通分量数
    while(numS>1){               //若连通分量数大于1
        从E中取出权值最小的边(v,u);
        if(v 和 u 属于T中不同的连通分量){
            T=T∪{(v,u)};         //将此边加入生成树中
            numS--;              //连通分量数减1
        }
    }
}
```

##### 时间复杂度分析

在 Kruskal 算法中，每当选择一条连接两棵不同树的边时，这两棵树将通过这条边合并为一棵更大的树，随着算法的进行，整个森林逐渐合并成一棵树。  
考虑到算法效率，在最坏情况下需要对所有的 $|E|$ 条边各扫描一次。  
通常，边会存储在一个堆（见第 7 章）中，每次从中选出最小权值的边所需时间为 $O(\log_2|E|)$。  
同时，使用**并查集**来快速确定两个顶点是否属于同一集合的时间复杂度为 $O(\alpha(|V|))$，这里 $\alpha(|V|)$ 增长极其缓慢，可视为常数。  
因此，Kruskal 算法的总时间复杂度为 $O(|E|\log_2|E|)$，不依赖于 $|V|$，这使得它特别适合于处理**边稀疏但顶点较多**的图。
[[并查集]]

