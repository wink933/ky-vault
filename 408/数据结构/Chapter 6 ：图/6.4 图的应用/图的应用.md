---
title: 图的应用
tags:
  - "#图的应用"
  - "#最小生成树"
  - "#prim算法"
  - "#Kruskal算法"
  - "#最短路径"
  - "#Dijkstra算法"
  - "#Floyd算法"
  - "#有向无环图"
  - "#拓扑排序"
  - "#关键路径"
date: 2026-02-27
---
---







### 单源最短路径问题

#### 广度优先搜素（BFS）算法

广度优先搜索算法适用于求解**无权图**的最短路径。当图是带权图时，从一个顶点 $v_0$ 到图中任意另一个顶点 $v_i$ 的路径上所有边的权值之和，称为该路径的带权路径长度；其中，带权路径长度最小的路径（可能存在多条）称为**最短路径**。  
[[图的遍历#广度优先搜索]]




#### Dijkstra 算法求单源最短路径问题

##### 算法说明

Dijkstra 算法使用一个**集合 $S$** 记录已确定最短路径的顶点。  
初始时，将源点（顶点 0）放入 $S$；  
每当将一个新顶点 $i$ 加入 $S$ 后，需更新源点到所有尚未确定最短路径的顶点（集合 $V-S$ 中的顶点）的当前最短路径长度。  
算法执行过程中维护以下**三个辅助数组**：

- `final[]`：标记各顶点是否已找到最短路径（是否属于集合 $S$）。
    
- `dist[]`：记录从源点到各顶点的当前最短路径长度。初始化时，若存在从源点到顶点 $i$ 的直接边，则 `dist[i]` 为该边的权值，否则置为 $\infty$。
    
- `path[]`：`path[i]` 存储从源点到顶点 $i$ 的最短路径。算法结束后，可通过 `path[]` 数组回溯，重构出完整的最短路径。

![](file-20260228231426009.png) 
    
假设源点为顶点 0，集合 $S$ 初始仅含顶点 0。图以邻接矩阵 `arcs` 表示，其中 `arcs[i][j]` 为有向边 $<i,j>$ 的权值；若该边不存在，则 `arcs[i][j]` 为 $\infty$。

##### Dijkstra 算法的步骤如下（暂不考虑对 `path[]` 的操作）：

1. **初始化**：集合 $S={0}$，`dist[]` 的初始值为 `dist[i]=arcs[0][i]`，$i=1,2,\cdots,n-1$。  
2. **选择最短路径顶点**：从不在 $S$ 中的顶点集合 $(V-S)$ 中选出顶点 $j$，使得 `dist[j]` 最小，此时，顶点 $j$ 即为当前从源点出发的最短路径的终点，将其加入集合 $S$。  
3. **松弛操作**：对每个从顶点 $j$ 出发的邻接顶点 $k$（`arcs[j][k]` $\ne \infty$），若 `dist[j] + arcs[j][k] < dist[k]`，则更新 `dist[k] = dist[j] + arcs[j][k]`。  
4. 重复步骤 2~3共 $n-1$ 次，直至所有顶点都包含在集合 $S$ 中。

##### 举例

每个新顶点加入集合 $S$ 后，都可能发现到达其他尚未确定最短路径顶点的更短路径，从而需要更新相应的 `dist[]` 值。以右图为例，设源点为 $v_0$，初始时 $S={v_0}$，`dist[1]=3`，`dist[2]=7`。将 $v_1$ 加入集合 $S$ 后，发现路径 $v_0\to v_1\to v_2$ 的长度为 4（`dist[1] + arcs[1][2] = 3 + 1 = 4`），小于原来的 7，因此将 `dist[2]` 更新为 4。
![](file-20260228231426011%201.png)
##### Dijkstra 算法与 Prim 算法有何异同之处？


##### 算法过程举例
对图 6.17 中的图应用 Dijkstra 算法求从顶点 1 出发到其余各顶点的最短路径的过程，如表 6.2 所示。算法执行过程的说明如下。

![](file-20260228231426012.png)

1. 初始化：集合 $S$ 初始为 ${v_1}$，从 $v_1$ 可达 $v_2$ 和 $v_5$，不可达 $v_3$ 和 $v_4$，因此 `dist[]` 数组的初始值为 `dist[2]=10`，`dist[3]=\infty`，`dist[4]=\infty`，`dist[5]=5`。

2. 第 1 轮：选出最小值 `dist[5]`，将 $v_5$ 加入集合 $S$，此时已确定 $v_1$ 到 $v_5$ 的最短路径。检查从 $v_5$ 出发的邻接边：$v_5$ 可达 $v_2$，$v_1\to v_5\to v_2$ 的长度为 8，小于当前 `dist[2]=10`，更新 `dist[2]=8`；$v_5$ 可达 $v_3$，$v_1\to v_5\to v_3$ 的长度为 14，更新 `dist[3]=14`；$v_5$ 可达 $v_4$，$v_1\to v_5\to v_4$ 的长度为 7，更新 `dist[4]=7`。

3. 第 2 轮：选出最小值 `dist[4]`，将 $v_4$ 加入集合 $S$。检查从 $v_4$ 出发的邻接边：$v_4$ 不可达 $v_2$，`dist[2]` 不变；$v_4$ 可达 $v_3$，$v_1\to v_5\to v_4\to v_3$ 的长度为 13，小于当前 `dist[3]=14`，更新 `dist[3]=13`。

4. 第 3 轮：选出最小值 `dist[2]`，将 $v_2$ 加入集合 $S$。检查从 $v_2$ 出发的邻接边：$v_2$ 可达 $v_3$，$v_1\to v_5\to v_2\to v_3$ 的长度为 9，小于当前 `dist[3]=13`，更新 `dist[3]=9`。

5. 第 4 轮：选出唯一最小值 `dist[3]`，将 $v_3$ 加入集合 $S$，此时，所有顶点均已包含在集合 $S$ 中。
![](file-20260228231426007.png)

##### 时间复杂度分析

1. 使用**邻接矩阵**表示图，并采用线性扫描 `dist[]` 查找最小值时，Dijkstra 算法的时间复杂度为 $O(|V|^2)$。  
2. 若改用**带权邻接表**，虽然松弛操作的总代价可降至 $O(|E|)$，但由于查找最小 `dist[]` 值仍需 $O(|V|)$ 时间，总时间复杂度仍为 $O(|V|^2)$。即使只需求解从源点到某一个特定顶点的最短路径，在最坏情况下仍需处理所有顶点，因此时间复杂度不变，仍为 $O(|V|^2)$。

##### 注意

Dijkstra 算法不适用于**存在负权边的图**。该算法基于**贪心策略**，**一旦顶点被加入集合 $S$，便不再更新其最短路径**。然而，若图中存在负权边，后续路径可能通过负权边“绕回”已确定的顶点，从而发现更短路径，而 Dijkstra 算法无法察觉这一变化，导致结果错误。例如，对于图 6.18 所示的带权有向图，Dijkstra 算法可能无法得到正确的最短路径。
![](file-20260228231426007%201.png)