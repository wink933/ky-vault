---
title: Prim算法
tags:
  - "#prim算法"
date: 2026-02-28
---

---

#### Prim 算法

Prim（普里姆）算法在执行过程上与求解单源最短路径的 Dijkstra 算法较为相似。

##### 算法思想

初始时，从图中任取一个顶点加入树 $T$，此时 $T$ 仅包含该顶点。接着，选择一个与当前 $T$ 中顶点集合距离最近的顶点，并将该顶点及其相连的最小权值边加入 $T$。每执行一次此操作，$T$ 中的顶点数和边数各增加 1。重复这一过程，直到图中所有顶点都被并入 $T$ 为止。最终得到的 $T$ 即为最小生成树，且其中必然含有 $n-1$ 条边。图 6.15 展示了 Prim 算法构造最小生成树的过程。
![](file-20260228231426010.png)

##### Prim 算法步骤

- 假设 $G={V,E}$ 是连通图，其最小生成树 $T=(U,E_T)$，$E_T$ 是 $T$ 中的边集合。

- 初始化：向空树 $T=(U,E_T)$ 中添加图 $G$ 的任意一个顶点 $u_0$，使得 $U={u_0}$，$E_T=\varnothing$。

- 循环（重复，直至 $U=V$）：从图 $G$ 中选择满足条件 ${(u,v)\mid u\in U,\ v\in V-U}$ 且具有最小权值的边 $(u,v)$，将其加入树 $T$，并更新 $U=U\cup{v}$，$E_T=E_T\cup{(u,v)}$。

##### Prim 算法的简单代码实现

```text
void Prim(G,T){
    T=∅;                 //初始化空树
    U={w};               //添加任意一个顶点w
    while((V-U)!=∅){     //若树中不含全部顶点
        设(u,v)是使u∈U 与 v∈(V-U)，且权值最小的边;
        T=T∪{(u,v)};     //边归入树
        U=U∪{v};         //顶点归入树
    }
}
```

##### 时间复杂度分析

在 Prim 算法中，每步都从当前已构建的树向外扩展一条最短边，逐步生长出整棵最小生成树。  
该算法的时间复杂度为 $O(|V|^2)$，与边数 $|E|$ 无关，因此特别适用于求解**边稠密**图的最小生成树。  
虽然采用其他方法能改进 Prim 算法的时间复杂度，但会增加实现的复杂度。


