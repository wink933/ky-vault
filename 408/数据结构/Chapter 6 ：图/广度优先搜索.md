---
title: 广度优先遍历
tags:
  - "#广度优先遍历"
  - "#BFS"
  - "#广度优先搜索"
  - "#图的遍历"
date: 2026-02-27
---
---

## 广度优先搜索


广度优先搜索（Breadth-First-Search，BFS）类似于树的层序遍历  。
[[二叉树的遍历#层次遍历（树的广度优先遍历）]]

### 基本思想

- 首先访问起始顶点 $v$，然后从 $v$ 出发，依次访问 $v$ 的所有未被访问过的邻接顶点 $w_1,w_2,\cdots,w_i$；  
- 随后依次访问 $w_1,w_2,\cdots,w_i$ 的所有尚未访问过的邻接顶点；
- 再从这些访问过的顶点出发，访问它们所有未被访问过的邻接顶点，直至图中所有可达顶点都被访问为止。
- 若此时图中仍有未被访问的顶点，则另选一个未访问的顶点作为新的起始点，重复上述过程，直至图中所有顶点均被访问。  
- [[Dijkstra 单源最短路径算法]]和 [[Prim 最小生成树算法]]也应用了类似的思想。

### 理解
广度优先搜索以起始顶点 $v$ 为中心，按路径长度递增的顺序访问所有从 $v$ 可达的顶点，即先访问距离为 1 的顶点，再访问距离为 2 的顶点，以此类推。  
BFS 是一种分层遍历过程：每完成一层的访问，便会处理下一层的所有顶点，而不会沿已访问路径回溯，因此通常以**非递归**方式实现。BFS 算法必须借助一个**辅助队列**，用于暂存当前层顶点的下一层邻接顶点。


### 基于算法的代码实现
#### 广度优先搜索算法的实现

```c
bool visited[MAX_VERTEX_NUM];        //访问标记数组
void BFSTraverse(Graph G){           //对图G进行广度优先遍历
    for(i=0;i<G.vexnum;++i)
        visited[i]=FALSE;            //访问标记数组初始化
    InitQueue(Q);                    //初始化辅助队列Q
    for(i=0;i<G.vexnum;++i)          //从0号顶点开始遍历
        if(!visited[i])              //对每个连通分量调用一次BFS()
            BFS(G,i);                //若v_i未访问过，从v_i开始调用BFS()
}
```
>这是针对非连通图的情况，若没有这个函数 ，则无法遍历图上的所有结点
#### 基于邻接表的广度优先搜索实现

```c
void BFS(ALGraph G,int i){
    visit(i);                        //访问初始顶点i
    visited[i]=TRUE;                 //对i做已访问标记
    EnQueue(Q,i);                    //顶点i入队
    while(!QueueEmpty(Q)){
        DeQueue(Q,v);                //队首顶点v出队
        for(p=G.vertices[v].firstarc;p;p=p->nextarc){ //检测v的所有邻接点
            w=p->adjvex;
            if(visited[w]==FALSE){
                visit(w);            //w为v的尚未访问的邻接点，访问w
                visited[w]=TRUE;     //对w做已访问标记
                EnQueue(Q,w);        //顶点w入队
            }
        }
    }
}
```

#### 基于邻接矩阵的广度优先搜索实现

```c
void BFS(MGraph G,int i){
    visit(i);                        //访问初始顶点i
    visited[i]=TRUE;                 //对i做已访问标记
    EnQueue(Q,i);                    //顶点i入队
    while(!QueueEmpty(Q)){
        DeQueue(Q,v);                //队首顶点v出队
        for(w=0;w<G.vexnum;w++)      //检测v的所有邻接点
            if(visited[w]==FALSE&&G.edge[v][w]==1){
                visit(w);            //w为v的尚未访问的邻接点，访问w
                visited[w]=TRUE;     //对w做已访问标记
                EnQueue(Q,w);        //顶点w入队
            }
    }
}
```

#### 说明

辅助数组 visited[]用于标记顶点是否已被访问，初始值均为 FALSE。在遍历过程中，一旦顶点 $v_i$被访问，立即置 visited[i]=TRUE，以防止重复访问。


给定图 $G$ 如图 6.11 所示，假设从顶点 $a$ 开始遍历，BFS 的执行过程如下：$a$ 先入队；队列非空，取出 $a$，发现其邻接点 $b$ 和 $c$ 均未访问，依次访问并入队；取出 $b$，访问其未访问的邻接点 $d$ 和 $e$，并入队（$a$ 虽与 $b$ 也邻接，但已访问，故跳过）；取出 $c$，访问其未访问的邻接点 $f$ 和 $g$，并入队；取出 $d$，其邻接点均已访问，无操作；取出 $e$，访问其未访问邻接点 $h$，并入队；继续处理 $f,g,h$，均无新邻接点可访问；最终队列为空，遍历结束。遍历结果为 _abcdefgh_。
![](assets/广度优先搜索/file-20260227142113824.png)

上述过程与二叉树的层序遍历完全一致，说明图的 **BFS** 是树层序遍历算法的自然推广。


### 遍历序列的可变性

1. **同一个图的邻接矩阵表示方式唯一，因此广度优先道历序列唯一**

2. **同一个图邻接表表示方式不唯一，因此广度优先遍历序列不唯一**


### BFS 算法的性能分析

1. 无论采用邻接表还是邻接矩阵存储，BFS 算法都需要借助一个**辅助队列 $Q$** 来实现逐层访问。每个顶点最多入队一次，在最坏的情况下，空间复杂度为 $O(|V|)$。

2. 遍历图的过程实质上是对每个顶点查找其邻接点的过程，耗费的时间取决于所采用的存储结构。  
	- 采用**邻接表**存储时：每个顶点均需搜索（或入队）一次，时间复杂度为 $O(|V|)$；在搜索每个顶点的邻接点时，每条边均需访问一次，时间复杂度为 $O(|E|)$；总的时间复杂度为 $O(|V|+|E|)$。  
	- 采用**邻接矩阵**存储时：查找每个顶点的邻接点所需的时间为 $O(|V|)$，总的时间复杂度为 $O(|V|^2)$。


