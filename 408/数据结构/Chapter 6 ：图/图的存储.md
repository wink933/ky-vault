---
title: 图的存储
tags:
  - "#邻接矩阵法"
  - "#邻接表法"
  - "#十字矩阵法"
  - "#邻接多重表法"
date: 2026-02-27
---
---

## 图的存储

图的存储必须要完整、准确地反映**顶点集和边集的信息**。针对不同的图结构和算法需求，选择合适的存储方式将显著影响程序的效率，因此所采用的存储结构应与待求解的问题相适应。

### 邻接矩阵法

#### 定义

邻接矩阵存储方法通过一个**一维数组存储图中顶点的信息**，并用一个**二维数组存储边的信息**（各顶点之间的邻接关系）。这个用于存储邻接关系的二维数组称为**邻接矩阵**。
##### 不带权图
顶点数为 $n$ 的图 $G=(V,E)$ 的邻接矩阵 $A$ 是 $n\times n$ 的，将图 $G$ 的顶点编号为 $v_1,v_2,\cdots,v_n$，则

$$  
A[i][j]=  
\begin{cases}  
1, & (v_i,v_j)\text{或}\langle v_i,v_j\rangle \text{是}E(G)\text{中的边}\\
0, & (v_i,v_j)\text{或}\langle v_i,v_j\rangle \text{不是}E(G)\text{中的边}  
\end{cases}  
$$
##### 带权图
若顶点 $v_i$ 和 $v_j$ 之间有边相连，则邻接矩阵中对应位置存放该**边的权值**；若顶点 $v_i$ 和 $v_j$ 不相连，则通常用 0 或 $\infty$ 表示这两个顶点之间不存在边：

$$  
A[i][j]=  
\begin{cases}  
w_{ij}, & (v_i,v_j)\text{或}\langle v_i,v_j\rangle \text{是}E(G)\text{中的边}\\ 
0\text{或}\infty, & (v_i,v_j)\text{或}\langle v_i,v_j\rangle \text{不是}E(G)\text{中的边}  
\end{cases}  
$$
##### 图示

图 6.5 展示了有向图、无向图及带权图（网）对应的邻接矩阵。

![](assets/图的存储/file-20260227110527755.png)
#### 结构体定义

```c
#define MaxVertexNum 100            //顶点数目的最大值
typedef char VertexType;            //顶点对应的数据类型
typedef int EdgeType;               //边对应的数据类型
typedef struct{
    VertexType vex[MaxVertexNum];   //顶点表
    EdgeType edge[MaxVertexNum][MaxVertexNum]; //邻接矩阵，边表
    int vexnum,arcnum;              //图的当前顶点数和边数
}MGraph;
```

#### 注意  
1. 在简单应用中，可以直接使用二维数组作为图的邻接矩阵（顶点信息等均可省略）。  
2. 当邻接矩阵元素仅表示相应边是否存在时，EdgeType 可用值为 0 和 1 的枚举类型。  
3. 邻接矩阵表示法的空间复杂度为 $O(n^2)$，其中 $n$ 为图的顶点数 $|V|$。

#### 特点

1. 无向图的邻接矩阵一定是**对称矩阵**，因此实际存储时只需保存上（或下）三角部分。在顶点编号固定的条件下，该邻接矩阵是唯一的。[[特殊矩阵#对称矩阵]]

2. 对于**无向图**，邻接矩阵第 $i$ 行（或第 $i$ 列）非零元素（或非 $\infty$ 元素）的数量正好是顶点 $i$ 的**度** $TD(v_i)$。

3. 对于**有向图**，邻接矩阵第 $i$ 行非零元素（或非 $\infty$ 元素）的数量是顶点 $i$ 的**出度** $OD(v_i)$；第 $i$ 列非零元素（或非 $\infty$ 元素）的数量则是顶点 $i$ 的**入度** $ID(v_i)$；两者之和是顶点 $i$ 的**度** $TD(v_i)$。
   
4. 使用邻接矩阵存储图时，很容易判断任意两个顶点之间是否有边相连，但要确定图中有多少条边，通常需要**遍历整个矩阵**，**时间代价较大**。  
   
5. **稠密图**（边数较多的图）更适合采用邻接矩阵存储。
   >若边数少会造成空间浪费

6. 设图 $G$ 的邻接矩阵为 $A$，$A^n$ 的元素 $A^n[i][j]$ 代表从顶点 $i$ 到顶点 $j$ 长度为 $n$ 的路径数量。这一结论了解即可，具体证明可参考离散数学教材。
   >![](assets/图的存储/file-20260227112138879.png)
   


### 邻接表法

#### 定义

当图为**稀疏图**时，使用邻接矩阵法显然会浪费大量存储空间。而邻接表法结合了**顺序存储与链式存储**的优点，能显著减少这种不必要的空间开销。

所谓邻接表，是指对图 $G$ 中的每个顶点 $v_i$ 建立一个单链表。第 $i$ 个单链表中的结点表示依附于顶点 $v_i$ 的边（对于有向图，这些边是以 $v_i$ 为尾的弧），该链表称为顶点 $v_i$ 的边表（有向图中也称出边表）。边表的头指针与顶点的数据等信息采用顺序存储，称为顶点表。因此，邻接表中包含两类结点：顶点表结点和边表结点，如图 6.6 所示。

---

顶点表结点由两个域组成：顶点域（data）存储顶点 $v_i$ 的相关信息，边表头指针域（firstarc）指向其第一条邻接边的边表结点。边表结点至少包含两个域：邻接点域（adjvex）存储与该顶点邻接的另一顶点编号，指针域（nextarc）指向下一条边的边表结点。

考点追踪 ▶ 图的邻接表存储的应用（2014）

无向图和有向图的邻接表表示分别如图 6.7 和图 6.8 所示。

图的邻接表存储结构定义如下：

```c
#define MaxVertexNum 100            //图中顶点数目的最大值
typedef struct ArcNode{             //边表结点
    int adjvex;                     //该弧所指向的顶点的位置
    struct ArcNode *nextarc;        //指向下一条弧的指针
    //InfoType info;                //网的边权值
}ArcNode;
typedef struct VNode{               //顶点表结点
    VertexType data;                //顶点信息
    ArcNode *firstarc;              //指向第一条依附该顶点的弧的指针
}VNode,AdjList[MaxVertexNum];
typedef struct{
    AdjList vertices;               //邻接表
    int vexnum,arcnum;              //图的顶点数和弧数
}ALGraph;                           //ALGraph 是以邻接表存储的图类型
```

邻接表表示法具有以下特点：  
① 若 $G$ 为无向图，所需存储空间为 $O(|V|+2|E|)$；若为有向图，则为 $O(|V|+|E|)$。前者包含系数 2，是因为无向图中每条边在邻接表中会出现两次。

考点追踪 ▶ 邻接矩阵法和邻接表法的适用性分析（2011）

② 对于稀疏图（边数较少的图），采用邻接表表示能极大节省存储空间。  
③ 在查找指定顶点的所有邻接点时，邻接表只需遍历对应的边表；而邻接矩阵则需扫描对应整行，效率较低。然而，若要判断两个顶点之间是否存在边，邻接矩阵支持 $O(1)$ 的直接访问；而邻接表需要线性查找对应的边表，效率较低。  
④ 在无向图的邻接表中，顶点的度等于其邻接表中边表结点的个数。对于有向图，顶点的出度等于其邻接表中边表结点的个数；而入度则需遍历所有顶点的边表，统计所有边表中（adjvex）域等于该顶点编号的结点总数。  
⑤ 邻接表的表示不唯一，因为每个顶点对应的边表中，各边结点的链接顺序可以是任意的，它取决于建立邻接表的算法及输入边的次序。