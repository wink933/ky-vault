---
title: 深度优先搜索
tags:
date: 2026-02-28
---

---

## 深度优先搜索



与广度优先搜索不同，**深度优先搜索**（Depth-First-Search，DFS）类似于树的**先序遍历**。正如其名所暗示的那样，这种搜索算法遵循尽可能“深”地探索一个图的策略。
[[树和森林的遍历#树的遍历]]
### 基本思想
首先访问图中的某一起始顶点 $v$，然后从 $v$ 出发，访问 $v$ 的一个未访问邻接顶点 $w_1$，再访问 $w_1$ 的一个未访问邻接顶点 $w_2$······以此类推。  
当无法继续向下访问时，回退至上一顶点（递归返回），检查其是否还有未访问的邻接顶点。  
若有，则从该顶点开始继续上述搜索过程，直到图中所有顶点均被访问为止。

### 基于算法的代码实现

#### 深度优先搜索算法的实现

```c
bool visited[MAX_VERTEX_NUM];        //访问标记数组
void DFSTraverse(Graph G){           //对图G进行深度优先遍历
    for(i=0;i<G.vexnum;++i)
        visited[i]=FALSE;            //初始化已访问标记数组
    for(i=0;i<G.vexnum;i++)          //本代码从v0开始遍历
        if(!visited[i])              //对尚未访问的顶点调用DFS()
            DFS(G,i);
}
```

#### 基于邻接表的深度优先搜索实现

```c
void DFS(ALGraph G,int i){
    visit(i);                        //访问初始顶点i
    visited[i]=TRUE;                 //对i做已访问标记
    for(p=G.vertices[i].firstarc;p;p=p->【看不清】){
        j=p->adjvex;
        if(visited[j]==FALSE)
            DFS(G,j);                //j为i的尚未访问的邻接点，递归访问j
    }
}
```

#### 基于邻接矩阵的深度优先搜索实现

```c
void DFS(MGraph G,int i){
    visit(i);                        //访问初始顶点i
    visited[i]=TRUE;                 //对i做已访问标记
    for(j=0;j<G.vexnum;j++){         //检测i的所有邻接点
        if(visited[j]==FALSE&&G.edge[i][j]==1)
            DFS(G,j);                //j为i的尚未访问的邻接点，递归访问j
    }
}
```

### 说明

以图 6.11 的图 $G$ 为例，DFS 的执行过程如下：  
首先访问顶点 $a$，并置 $a$ 访问标记。  
接着访问与 $a$ 邻接且未被访问的 $b$，置 $b$ 访问标记；  
随后访问与 $b$ 邻接且未被访问的 $d$，置 $d$ 访问标记。  
此时，由于 $d$ 没有更多未被访问的邻接顶点，因此返回上一个访问的 $b$，继续访问其未被访问的邻接顶点 $e$，置 $e$ 访问标记，以此类推，直至图中所有顶点都被访问一次。遍历结果为 _abdehcfg_。
![](file-20260228231110948.png)

### 注意
**图的邻接矩阵表示是唯一的**，这意味着基于邻接矩阵和同一源点出发遍历得到的 DFS 和 BFS 序列是唯一的。  
然而，对邻接表来说，若边的输入顺序不同，则生成的邻接表也会不同。因此，**对同一个图，基于邻接表的遍历得到的 DFS 序列和 BFS 序列可能不是唯一的。**



### DFS 算法的性能分析

- DFS 算法通常以**递归**形式实现，其执行过程依赖系统提供的递归工作栈，在最坏情况下，递归深度可达 $|V|$，因此空间复杂度为 $O(|V|)$。

- 图的遍历本质上是通过边依次访问邻接点的过程。因此，无论是深度优先搜索还是广度优先搜索，其时间复杂度仅取决于图的存储结构，而与访问顺序无关。具体而言：采用**邻接矩阵**存储时，对每个顶点需扫描整行以查找邻接点，总时间复杂度为 $O(|V|^2)$；采用**邻接表**存储时，每个顶点和每条边均被访问常数次，总时间复杂度为 $O(|V|+|E|)$。
- 分析可参考BFS[[图的遍历#BFS 算法的性能分析]]

### 深度优先的生成树和生成森林

与广度优先搜索类似，深度优先搜索在遍历过程中也会形成一棵深度优先生成树。其存在的前提是图必须是**连通**的。  
只有对连通图调用 DFS 时，才能得到一棵覆盖所有顶点的生成树；  
若图是**非连通**的，DFS 将为每个连通分量分别生成一棵树，这些树共同构成深度优先生成森林，如图 6.13 所示。

#### 注意
不论是采用 DFS 还是采用 BFS 方法，基于邻接表得到的生成树是不唯一的，而基于邻接矩阵和同一源点所得的生成树是唯一的。

![](file-20260227155616422.png)

---
