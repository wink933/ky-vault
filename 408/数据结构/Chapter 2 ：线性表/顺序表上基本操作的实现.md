---
title: 顺序表上基本操作的实现
tags:
  - "#顺序表"
categories:
date: 2026-02-08
---
---

### 顺序表的初始化

- 对于静态分配来说，数组空间已经由编译器自行分配，因此初始化时只需将当前长度置0，即
```
 L.length=0;  
```
>若不对data数组进行初始化，因为内存当中可能会遗留一些脏数据，故data数组可能会被写入这些脏数据
>![](assets/顺序表上基本操作的实现/file-20260208213120781.png)
>访问数据时使用查找操作最为合适

 - 对于动态分配来说，需要在运行时为顺序表分配初始大小的数组空间，并设置长度和容量
```
 L.length=0; 
 MaxSize=InitSize; 
```

### 顺序表的插入

#### 基本操作
- 在顺序表的第$i(1\le i \le L.length+1)$个位置插入新元素e。若i超出合法范围，或存储空间已满，则插入失败，返回false；否则，将第i个元素及其后的所有元素依次后移一位，腾出一个空位置插入e，表长加1，返回true。
	  ![](assets/顺序表上基本操作的实现/file-20260209202716277.png)

#### 时间复杂度分析

- 最好情况：在表尾插入（$i=n+1$），无须移动元素，时间复杂度为 $O(1)$。

- 最坏情况：在表头插入（$i=1$），需移动全部 $n$ 个元素，时间复杂度为 $O(n)$。

- 平均情况：设在第 $i$ 个位置插入的概率为 $p_i=1/(n+1)$，则平均移动次数为

$$  
\sum_{i=1}^{n+1} p_i(n-i+1)  
=\sum_{i=1}^{n+1}\frac{1}{n+1}(n-i+1)  
=\frac{1}{n+1}\sum_{i=1}^{n+1}(n-i+1)  
=\frac{1}{n+1}\cdot\frac{n(n+1)}{2}  
=\frac{n}{2}  
$$

>因此，插入操作的平均时间复杂度为 $O(n)$。
