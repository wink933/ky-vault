---
title: 循环链表
tags:
  - "#循环链表"
categories:
date: 2026-02-11
---
---

## 循环链表

### 循环单链表

#### 理解

循环单链表与普通单链表的主要区别在于：表中最后一个结点的next域不再为NULL，而是指向头结点，从而使整个链表形成一个环。这种结构使得从任意一个结点出发均可遍历整个循环单链表，而不仅限于从表头开始。

![](assets/循环链表/file-20260211171858328.png)

尾结点*r 的 next 指向头结点，因此链表中不存在 **next** 为 **NULL** 的结点。判空条件不再是检查头指针 L 是否为空，而是检查头结点的 next 是否指向自身（L->next==L）。

循环单链表的插入和删除操作与普通单链表基本相同，但有一个关键差异：在表尾进行操作时，需要特别处理以维持链表的循环特性。然而，正是因为循环单链表是一个环，在任何位置上的插入和删除操作都是等价的，因此无须判断是否到达表尾。

为了提高效率，循环单链表有时不设头指针，而仅设置尾指针 r。此时，在表头或表尾插入元素的时间复杂度均为 O(1)。若使用头指针，则表尾插入需要遍历整个链表，时间复杂度为 O(n)。例如，在表尾插入新结点*s 时，需要执行以下步骤：令 s->next=r->next（使新结点的后继指向头结点，以维持环状结构）；将 r->next 指向新结点*s；更新 r 为新结点*s。

### 循环双链表

#### 理解

基于循环单链表的概念，不难推导出循环双链表。不同之处在于：循环双链表中的每个结点不仅包含指向下一个结点的next域，还包含指向前一个结点的prior域。特别地，头结点的prior

需要指向表尾结点，从而形成一个完整的环形结构。
![](assets/循环链表/file-20260211172025459.png)

设尾结点为*p，则 p->next 应指向头结点 L；同时，L->prior 应指向*p。当循环双链表为空时，其头结点 L 的 prior 和 next 都指向自身（L->prior== L且 L->next==L）。