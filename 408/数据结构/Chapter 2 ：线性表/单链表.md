---
title: 链表
tags:
  - "#单链表"
categories:
date: 2026-02-10
---
---

### 为什么线性表使用链式存储？

#### 理解

顺序表支持随机存取任意元素，但插入和删除操作都需要移动大量元素，效率低。
链式存储的线性表不要求地址连续的存储单元；通过指针建立元素之间的逻辑关系，因此插入和删除操作无需移动元素，只需修改相关指针，效率较高，但是这样做导致失去了顺序表的随机存取能力，所以只能从头开始顺序访问

#### 总结

|     | 顺序表              | 链表                           |
| --- | ---------------- | ---------------------------- |
| 优点  | 可随机存取，存储密度高      | 不要求大片连续空间，改变容量方便             |
| 缺点  | 要求大片连续空间，改变容量不方便 | 不可随机存取，要耗费一定空间存储指针因此导致存储密度不高 |

### 单链表的定义

#### 定义

线性表的链式存储也称单链表。它通过一组**任意的存储单元**（不要求地址连续）来存储线性表中的元素数据。为了建立数据元素之间的线性关系，每个链表结点除了存放元素自身的信息外，还需要额外设置一个指向其后继结点的指针。
>下图为单链表的结点结构![](assets/单链表/file-20260210202202992.png)

#### 单链表的结构体定义

![](assets/单链表/file-20260210202316471.png)
>typedef用于将数据类型重命名
>
>这里的typedef就是将struct LNode重命名成了LNode或者*LinkList

>LNode表示的是这个结点，*LinkList 表示的则是指向这个结点的指针


#### 头指针

##### 头指针的定义

通常使用头指针L（或head等）来标识一个单链表，该指针指向链表的起始位置。当头指针为NULL时，**表示链表为空**。此外，为了简化操作，在单链表的第一个数据结点之前常附加一个特殊的结点，称头结点。头结点的数据域一般**不存放有效数据**（但可用于记录表长等信息）。**在带头结点的单链表中**，头指针L指向头结点，而头结点的 next 指向第一个数据结点。在**不带头结点的单链表中**，头指针L直接指向第一个数据结点。无论哪种形式，表尾结点的指针域为 NULL（图中用“^”表示）。

![](assets/单链表/file-20260210204059525.png)

##### 头指针和头结点的关系

>头指针始终指向链表的第一个结点  
>头结点仅存在于带头结点的链表中，它是链表的第一个结点，其数据域通常不存放实际数据


##### 头结点的优点

1. **操作统一性**：第一个数据结点的位置存储在头结点的指针域中，因此在链表首部进行插入和删除操作时，与其他位置的操作逻辑一致，无须特别处理。
2. **空表与非空表处理统一**：无论链表是否为空，头指针始终是一个非空指针，因为它始终指向头结点，而如果一个链表是空表，则它的头结点的next为NULL，从而避免了对空表的单独判断。


### 单链表上的基本操作

#### 单链表的初始化

##### 带头结点
![](assets/单链表/file-20260210205234945.png)

需要先创建一个头结点，然后令头指针L指向该头结点，头结点的next指针初始化为NULL。

##### 不带头结点
![](assets/单链表/file-20260210205420103.png)

只需将头指针L初始化为NULL


#### 求表长操作

##### 操作说明

求表长操作是指统计单链表中数据结点的个数，不包括头结点，从第一个数据结点开始依次遍历，因此需要设置一个计数变量，每访问一个结点，值加一，直到遇到NULL，说明到达了表尾。

##### 代码定义

![](assets/单链表/file-20260210205713411.png)

##### 时间复杂度分析

时间复杂度为$O(n)$，因为需要遍历n个结点


#### 单链表的插入

##### 操作说明

