---
title: 反转链表
tags:
  - "#反转链表"
date: 2026-02-19
---


###  反转链表要做什么？

把链表方向全部翻过来：

`1 -> 2 -> 3 -> null`  
变成  
`3 -> 2 -> 1 -> null`

**核心思想：**
- 改变每个节点的 `next` 指针指向其前驱。
- **关键操作是“断链 + 反转 + 连接”三步走。**

---

###  三种反转方法详解（含对比）

#### ✅ 方法一：迭代法 —— 最推荐（稳定、高效、无递归开销）

##### 🧠 思路

使用三个指针：

- `prev`：已反转部分的头节点（初始为 `NULL`）
- `cur`：当前要处理的节点（初始为 `head`）
- `nxt`：暂存 `cur->next`，防止断链

##### 🔄 步骤（每轮执行三步）

1. **保存后路**：`nxt = cur->next`
2. **反转指向**：`cur->next = prev`
3. **整体前进**：`prev = cur; cur = nxt`

循环结束时，`prev` 即为新链表的头节点。

##### 💡 代码（C/C++ 风格伪码）

```c
Node* reverse(Node* head){
    Node* prev = NULL;
    Node* cur = head;
    while(cur != NULL){
        Node* nxt = cur->next; // 1. 存后路
        cur->next = prev;      // 2. 反转
        prev = cur;            // 3. 前进
        cur = nxt;
    }
    return prev;
}
```

##### ⏱️ 复杂度

- 时间复杂度：`O(n)`
- 空间复杂度：`O(1)`

> ✅ **优点**：无递归、空间效率高，适合大规模链表。
> ❗ **易错点**：
> - 忘记保存 `cur->next`
> - 最终返回值不是 `prev`（而是原 `head`）
> - 循环条件写成 `cur != NULL` 时，需确保 `prev` 是最终头节点

---

#### ✅ 方法二：递归法 —— 思路清晰但有风险

##### 🧠 思路

- 先递归反转后半部分链表。
- 再将当前节点接到新链表的末尾。

##### 💡 代码（C/C++ 风格伪码）

```c
Node* reverse(Node* head){
    if(head == NULL || head->next == NULL) return head;
    Node* newHead = reverse(head->next); // 递归反转后半部分
    head->next->next = head;             // 将原head接到新链表末尾
    head->next = NULL;                   // 断开原连接，防止环路
    return newHead;
}
```

##### ⏱️ 复杂度

- 时间复杂度：`O(n)`
- 空间复杂度：`O(n)`（递归栈深度）

> ✅ **优点**：逻辑简洁、易理解。
> ❗ **易错点**：
> - 忘记 `head->next = NULL`
> - 未处理空链表或单节点情况
> - 可能栈溢出（大链表时风险高）

---

#### ✅ 方法三：头插法 —— 实质是迭代法的变体

##### 🧠 思路

从原链表依次取节点，**插入到新链表头部**。

##### 💡 代码（C/C++ 风格伪码）

```c
Node* reverse(Node* head){
    Node* newHead = NULL;
    Node* cur = head;
    while(cur){
        Node* nxt = cur->next;
        cur->next = newHead;   // 头插
        newHead = cur;
        cur = nxt;
    }
    return newHead;
}
```

##### ⏱️ 复杂度

- 时间复杂度：`O(n)`
- 空间复杂度：`O(1)`

> ✅ **优点**：逻辑清晰，与迭代法本质相同。
> ❗ **易错点**：
> - 未初始化 `newHead = NULL`
> - 循环条件写错（如用 `cur != head`）

---

### 📊 方法对比表

| 方法       | 时间复杂度 | 空间复杂度 | 是否递归 | 易错点                     | 推荐场景             |
|------------|-------------|--------------|-----------|--------------------------|----------------------|
| 迭代法     | O(n)        | O(1)         | 否        | 保存后路、返回值错误      | 大规模链表、工程实践 |
| 递归法     | O(n)        | O(n)         | 是        | 忘记断链、栈溢出风险      | 理解原理、小数据量   |
| 头插法     | O(n)        | O(1)         | 否        | 初始化错误、循环条件错    | 教学演示、理解本质   |

> 💡 **建议**：考研复习优先掌握迭代法，面试中可展示递归法思路。工程开发推荐使用迭代法。

---

### ⚠️ 反转链表最容易错的点（重点提醒）

1. **未保存 `cur->next` 导致断链**
   - 一定要先存后路再反转！

2. **返回值错误**
   - 最终头节点是 `prev` 或 `newHead`，不是原 `head`

3. **递归法忘记 `head->next = NULL`**
   - 否则会形成环（如：1→2→3 反转后变成 3→2→1→2）

4. **未处理空链表或单节点情况**
   - 基础边界条件必须覆盖！

5. **循环终止条件错误**
   - 如 `while(cur != NULL)`，但忘记更新 `cur` 导致死循环

---

### 🧪 实际应用与扩展思考（考研/面试加分项）

#### 1️⃣ 反转链表的变种题型：

- **反转前 k 个节点**：需维护分段逻辑。
- **按组反转**：如每3个一组反转，需用栈或递归辅助。
- **双向链表反转**：只需交换 `prev` 和 `next` 指针。

#### 2️⃣ 面试中如何表达？

> “我优先使用迭代法，因为其空间效率高、无递归开销。核心是三指针操作：保存后路 → 反转指向 → 前进。边界条件如空链表和单节点必须处理。”

#### 3️⃣ 考研真题风格题目（可补充练习）：

> **单选题**  
> 下列关于反转链表的说法，错误的是？  
> A. 迭代法空间复杂度为 O(1)  
> B. 递归法可能栈溢出  
> C. 头插法与迭代法本质不同  
> D. 反转后原头节点变为尾节点  

> **填空题**  
> 在反转链表的三指针方法中，`prev` 指向的是______部分的头。

> **简答题**  
> 请描述递归法反转链表的核心思想，并说明其潜在风险。

---




