---
title: 反转链表
tags:
  - "#反转链表"
date: 2026-02-19
---
---


##  反转链表要做什么？

把链表方向全部翻过来：

`1 -> 2 -> 3 -> null`  
变成  
`3 -> 2 -> 1 -> null`

核心：把每个结点的 `next` 指针改指向**前驱**。


##  迭代法

### 思路

用三个指针：

- `prev`：已反转部分的头（初始 `null`）
    
- `cur`：当前要处理的结点（初始 `head`）
    
- `nxt`：暂存 `cur.next`，防止断链
    

### 步骤（每轮做 3 件事）

1. `nxt = cur.next` （先存后路）
    
2. `cur.next = prev` （反转指向）
    
3. `prev = cur; cur = nxt`（整体前进）
    

循环结束时 `prev` 就是新头结点。

### 代码（C/C++ 风格伪码）

```c
Node* reverse(Node* head){
    Node* prev = NULL;
    Node* cur = head;
    while(cur != NULL){
        Node* nxt = cur->next; // 1.存后路
        cur->next = prev;      // 2.反转
        prev = cur;            // 3.前进
        cur = nxt;
    }
    return prev;
}
```

### 复杂度

- 时间：`O(n)`（每个结点处理一次）
    
- 空间：`O(1)`（只用常数指针）
    

---

##  递归法

### 思路

先把后面反转好，再把当前结点接到末尾：

假设 `reverse(head.next)` 已经把后面反转成新头 `newHead`  
原来的 `head.next` 现在是反转后链表的尾巴，把它指回 `head`：

- `head.next.next = head`
    
- `head.next = null`（断开原链接）
    

### 代码

```c
Node* reverse(Node* head){
    if(head == NULL || head->next == NULL) return head;
    Node* newHead = reverse(head->next);
    head->next->next = head;
    head->next = NULL;
    return newHead;
}
```

### 复杂度

- 时间：`O(n)`
    
- 空间：`O(n)`（递归栈深度 n，可能栈溢出）
    

---

##  头插法反转

从原链表依次取结点，**插到新链表头部**：

```c
Node* reverse(Node* head){
    Node* newHead = NULL;
    Node* cur = head;
    while(cur){
        Node* nxt = cur->next;
        cur->next = newHead;   // 头插
        newHead = cur;
        cur = nxt;
    }
    return newHead;
}
```

你会发现它本质上和“迭代三指针法”是一回事。

---

## 反转链表最容易错的点）

1. **忘了保存 `cur.next`**：一改 `cur.next = prev` 就断链了
    
2. **最后新头是谁**：是 `prev`（或 `newHead`），不是原 `head`
    
3. **递归法忘记 `head.next = NULL`**：会形成环
    
4. **空链表/单结点**：要能正确返回
    



