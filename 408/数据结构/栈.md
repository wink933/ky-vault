---

topic: "栈（Stack）"  
module: "栈队列数组"  
tags:

- "#栈"
    
- "#顺序栈"
    
- "#链栈"
    
- "#括号匹配"
    
- "#表达式求值"
    
- "#递归"  
exam_weight: "高"  
one_liner: "用“后进先出+栈顶单口”把嵌套/回退/递归状态压缩成可控的线性过程"  
updated: "2026-01-23"
    

---

> [!summary] 🧠 概念卡｜栈（栈队列数组）
> 
> - 核心得分点：**只允许在栈顶做插入/删除** → 形成 **LIFO（后进先出）** 的不变量
>     
> - 题目一眼识别：**“最近的/嵌套/回退/匹配/逆序/递归调用”** 基本都在暗示用栈
>     
> - 408常考实现：**顺序栈（数组+top）**、**链栈（单链表头插头删）**、栈满/栈空判定与越界
>     
> - 典型应用链：括号匹配 → 表达式求值/中缀转后缀 → 递归改非递归（DFS/遍历）
>     
> - 参考：王道第3章“栈、队列和数组”相关内容
>     

> [!note] 🎯 为什么需要（只写“问题与动机”，不写定义）
> 
> - 处理**嵌套结构**：括号、函数调用、递归层层进入又层层返回
>     
> - 处理**“最近一次”优先**：撤销/回退、最近访问、深度优先的回溯点
>     
> - 把“隐式状态”（递归栈/系统调用栈）**显式化**：便于控制、便于分析复杂度与边界
>     
> - 把非线性过程压成线性：只维护一个 **top/头结点** 就能管理一整条状态链
>     

> [!info] 🔗 机制链条（背诵版｜结构清晰）
> 
> - 触发(出现嵌套/回退/最近优先/递归深度)
>     
> - → 输入(待处理元素序列/符号流/子问题状态〈现场〉)
>     
> - → 核心步骤〔仅操作栈顶：Push(入栈)、Pop(出栈)、GetTop/Peek(读栈顶)、Empty/Full判定〕
>     
> - → 输出〔弹出顺序=逆序；或输出匹配/求值结果；或输出遍历序/路径〕
>     
> - → 副作用/代价〔时间：Push/Pop/Top均摊O(1)；空间：O(n)（含递归栈深度）〕
>     
> - → 失败/异常分支〔空栈出栈/取顶=下溢；顺序栈栈满入栈=上溢；递归过深=栈溢出；链栈一般无“满”但可能内存不足〕
>     

> [!tip] 🧭 流程/状态机（伪图示｜画关键分支）
> 
> - 顺序栈关键变量：`top`（指向栈顶位置/下一个可用位置，取决于约定）**约定要写清**
>     
> - 入栈三件套：判满 → top移动/赋值 → 返回成功
>     
> - 出栈三件套：判空 → 取元素 → top回退 → 返回成功
>     
> - 应用题的“分支点”：**遇到左括号Push；遇到右括号必须Pop并检查匹配；遇到运算符比较优先级并反复Pop**
>     
> 
> ```text
>            ┌───────────────┐
>            │   操作请求 op  │
>            └───────┬───────┘
>                    │
>        ┌───────────┼───────────┐
>        │           │           │
>      Push        Pop/Top     清空/遍历
>        │           │
>   Full?（顺序栈）  Empty?
>    │    │          │   │
>   是    否         是   否
>    │    │          │   │
> 上溢   写入+top++  下溢  读出(Top/Pop)+top--
> 
> 【括号匹配状态机】
> 读入符号 c
>  ├─ c 是左括号：Push(c)
>  ├─ c 是右括号：Empty? 是→失败；否→t=Pop(); t 与 c 不匹配→失败
>  └─ 结束：Empty? 否→失败；是→成功
> ```

> [!abstract] 🧾 最小对比表（只保留能得分的维度）
> 
> |维度|顺序栈（数组）|链栈（链表）|
> |---|---|---|
> |主要变量|`top`（栈顶指针/下标）|`head/top`（头指针=栈顶）|
> |判空|`top == -1` 或 `top == 0`（看约定）|`head == NULL`|
> |判满|`top == MaxSize-1`（或 `top == MaxSize`）|一般无固定“满”（受内存限制）|
> |Push/Pop时间|O(1)|O(1)|
> |空间代价|需预分配MaxSize，可能浪费|动态分配，指针域有额外开销|
> |典型坑|top约定写错、越界、溢出判断漏写|头插头删不彻底、内存泄漏/野指针|

> [!question] 🧩 真题命题信号词 → 直接定位
> 
> - “**后进先出 / LIFO / 栈顶 / 只能在一端操作**” → 直接问栈性质/基本操作
>     
> - “**括号匹配/表达式求值/中缀转后缀/逆波兰**” → 栈应用（遇符号就Push/按优先级Pop）
>     
> - “**递归调用过程/函数返回地址/系统栈**” → 递归=隐式栈，常问最大深度与空间O(深度)
>     
> - “给一串Push/Pop序列，问**是否可能/输出序列**” → 栈序列合法性（Pop不能超过已Push）
>     
> - “DFS/树遍历改非递归” → 显式栈模拟递归：Push现场，循环Pop展开
>     

> [!warning] ⚠ 易错点清单（带自检）
> 
> -  **top含义没写清**：top指“栈顶元素下标”还是“下一空位”？（两套判空/判满完全不同）
>     
> -  出栈顺序写反：栈弹出一定是**最近入栈的先出**
>     
> -  空栈还Pop/Top：是否先写了 `Empty?` 分支（下溢）
>     
> -  顺序栈漏判满：Push前是否 `Full?`（上溢）
>     
> -  链栈操作错方向：栈顶应在**链表头**（才能O(1)入/出），别放尾部导致O(n)
>     
> -  应用题漏“失败态”：括号匹配遇右括号时空栈、或结束后栈非空，都应判失败
>     
> -  递归复杂度只写时间不写空间：递归深度=栈空间，常考
>     

> [!success] ✅ 可直接套用的答题骨架（选择/简答/算法题通用）
> 
> - **不变量一句话**：仅栈顶可改；出栈序=入栈序的逆序；任意时刻Pop次数 ≤ Push次数
>     
> - **操作三件套模板**：前置(Empty?/Full?/指针合法) → 步骤(改top/改头指针) → 结果(返回元素/成功失败)
>     
> - **顺序栈伪码骨架**：
>     
>     - Push(x)：若Full→fail；`S[++top]=x`（或`S[top++]=x`按约定）→ok
>         
>     - Pop(&x)：若Empty→fail；`x=S[top--]`（或`x=S[--top]`）→ok
>         
> - **链栈伪码骨架**：Push=头插；Pop=删头并取值（先判空）
>     
> - **应用题防错口令**：遇“右括号/低优先级/回溯点”先**while/if弹栈检查**，最后记得“结束后清栈/判空”
>     

> [!quote] 🔗 知识网络（双链串题）
> 
> - [[队列]]：FIFO vs LIFO；常见对比题
>     
> - [[顺序表]]：顺序栈本质=受限顺序表（只在表尾操作）
>     
> - [[链表]]：链栈=受限链表（只在表头操作）
>     
> - [[括号匹配]]：栈的经典应用模型（失败态最爱考）
>     
> - [[表达式求值与中缀转后缀]]：运算符栈+操作数栈/单栈后缀求值
>     
> - [[递归与栈]]：递归深度=栈空间；递归改非递归=显式栈模拟
>     
> - [[DFS]]：深度优先=栈（显式/隐式）
>     
> - [[二叉树遍历]]：先/中/后序的非递归写法都靠栈
>