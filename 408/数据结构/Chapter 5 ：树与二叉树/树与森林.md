---
title: 树与森林
tags:
  - "#树"
  - "#森林"
date: 2026-02-24
---
---

## 树的存储结构

### 双亲表示法

#### 定义

双亲表示法使用一组连续的存储空间（如数组）来存放树中的所有结点。每个结点除包含数据域外，还增设一个“**伪指针**”域，用于指示其双亲结点在数组中的下标。如图 5.20 所示，根结点位于下标 0 处，其双亲域设为 -1，表示无双亲。
![](assets/树与森林/file-20260224140038061.png)

#### 结构体定义

```text
#define MAX_TREE_SIZE 100        //树中最多结点数
typedef struct{                 //树的结点定义
    ElemType data;              //数据元素
    int parent;                 //双亲位置域
}PTNode;
typedef struct{                 //树的类型定义
    PTNode nodes[MAX_TREE_SIZE];//双亲表示
    int n;                      //结点数
}PTree;
```

#### 双亲表示法的优缺点

双亲表示法利用了每个结点（除根结点外）有且仅有一个双亲的性质。因此，查找任意结点的双亲非常高效；  
然而，查找某结点的孩子则需**遍历整个数组**，效率较低。

#### 双亲表示法的具体应用

双亲表示法适用于找父亲多和找孩子少的场景，比如[[并查集]]



#### 区分树与二叉树的顺序存储结构
在树的双亲表示法中，数组下标用于标识结点，结点间的父子关系通过 parent 域显式记录。  
在二叉树的顺序存储结构中（如完全二叉树的数组表示），下标隐含了父子关系（例如，结点 $i$ 的左孩子为 $2i+1$，右孩子为 $2i+2$）。  
二叉树是树的特例，因此可以使用树的存储结构表示。但是，一般的树不能直接使用二叉树的顺序存储方式。
[[二叉树#顺序存储结构]]



### 孩子表示法

#### 定义
孩子表示法将每个结点的所有孩子视为一个[[线性表]]，并用[[单链表]]存储。整棵树则由 $n$ 个这样的孩子链表组成（叶结点对应空链表）。为便于访问，所有孩子链表的头指针被集中存放在一个[[顺序表]]（如数组）中，每个位置对应一个结点。图 5.21(a)展示了图 5.20(a)中树的孩子表示法。
![](assets/树与森林/file-20260224140842232.png)

#### 孩子表示法的优缺点

与双亲表示法相反，孩子表示法便于查找结点的孩子，但若要查找某结点的双亲，则需遍历所有孩子链表，检查是否包含该结点，效率较低。

### 孩子兄弟表示法

孩子兄弟表示法也称二叉树表示法，采用二叉链表作为树的存储结构。每个结点包含三部分：


数据域、指向第一个孩子的指针、指向下一个兄弟的指针（沿此指针可依次访问该结点的所有右侧兄弟），如图 5.21(b)所示。这种结构以“左孩子-右兄弟”的方式，将树映射为二叉树形式。

孩子兄弟表示法的存储结构描述如下：

```text
typedef struct CSNode{
    ElemType data;                              //数据域
    struct CSNode *firstchild,*nextsibling;     //第一个孩子和右兄弟指针
}CSNode,*CSTree;
```

孩子兄弟表示法具有良好的灵活性，其最大优点是能自然地将树转换为二叉树，从而复用二叉树的算法。查找孩子非常高效。然而，从当前结点高效回溯到其双亲较为困难。若在结点中增设一个 parent 指针域，则可高效查询双亲，形成一种三叉链表的存储结构。