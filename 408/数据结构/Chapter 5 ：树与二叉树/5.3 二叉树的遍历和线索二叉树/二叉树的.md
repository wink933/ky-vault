---
title: 二叉树的遍历
tags:
  - "#后序遍历"
  - "#中序遍历"
  - "#先序遍历"
  - "#层次遍历"
date: 2026-02-22
---
---









### 注意

**遍历是二叉树各类操作的基础**。例如，对于一棵给定二叉树，求结点的双亲、查找孩子结点、计算树的深度、统计叶结点数、判断两棵二叉树是否相同等操作，本质上都是在某种遍历过程中完成的。因此，必须深入理解并灵活运用各种遍历方法，以解决实际问题。

### 与算数表达式的联系

| 二叉树遍历    | 访问顺序      | 对应表达式记法   | 上例结果                         |
| -------- | --------- | --------- | ---------------------------- |
| **前序遍历** | 根 → 左 → 右 | **前缀表达式** | `* + a b - c d`              |
| **中序遍历** | 左 → 根 → 右 | **中缀表达式** | `a + b * c - d`（⚠️需括号才能保持原意） |
| **后序遍历** | 左 → 右 → 根 | **后缀表达式** | `a b + c d - *`              |
#### 中序遍历如何加括号？
运算优先级按照树的深度来判断，树越深，优先级就越高。
通常情况下，每遇到一个运算符，就要加上一对括号，这样一直加到最后，再把最外围的括号去掉。
### 由遍历序列构造二叉树


对于一棵给定的二叉树，其先序序列、中序序列、后序序列和层序序列都是唯一确定的。然而，仅凭这四种遍历序列中的任意一种，却无法唯一确定这棵二叉树。  
若已知**中序序列**，并辅以其他**三种遍历序列中的任意一种**，则可以唯一地重构出该二叉树。

#### 由先序序列和中序序列构造二叉树


在先序序列中，**第一个结点**必定是整棵二叉树的**根结点**；  
而在中序遍历中，根结点将中序序列划分为两个子序列：左侧子序列为左子树的中序序列，右侧子序列为右子树的中序序列。  
由于左右子树的结点数在先序和中序序列中一致，因此可据此从先序序列中分离出左右子树各自的先序子序列，如图5.11所示。通过递归地对左右子树重复上述过程，即可唯一地确定整棵二叉树。
![](file-20260228233136922.png)

##### 举例
求先序序列（ABCDEFGHI）和中序序列（BCAEDGHFI）所确定的二叉树。  
首先，由先序序列可知A为根结点。  
在中序序列中，A左侧的BC构成左子树的中序序列，右侧的EDGHFI构成右子树的中序序列。  
然后，由先序序列可知B是左子树的根结点，D是右子树的根结点。  
以此类推，将剩余结点递归分解，最终构造出的二叉树如图5.12(c)所示。
![](file-20260228233136918.png)
#### 由后序序列和中序序列构造二叉树

同后序序列与中序序列也可唯一确定一棵二叉树。  
后序序列的最后一个结点即为整棵树的根结点，它同样能将中序序列划分为左右子树的中序序列。  
随后，根据左右子树的结点数，可从后序序列中分离出对应的左右子树的后序序列，并递归构造，如图5.13所示。
![](file-20260228233136919.png)

#### 由层序序列和中序序列构造二叉树

在层序序列中，第一个结点必为二叉树的根结点，由此可在中序序列中划分出左右子树的中序序列。  
若存在左子树，则层序序列的第二个结点一定是左子树的根，可以进一步划分左子树；  
若存在右子树，则层序序列中紧接着的下一个结点一定是右子树的根，可以进一步划分右子树，如图5.14所示。  
通过逐层确定各子树的根结点并递归划分，即可唯一确定这棵二叉树。
![](file-20260228233136920.png)

#### 由先序序列和后序序列求出共有多少种可能的二叉树

##### 结论
仅凭先序序列和后序序列**无法唯一确定**一棵二叉树，往往会产生多种可能的树形结构。  
例如，图5.15所示的两棵二叉树的先序序列均为AB，后序序列均为BA，层序序列均为AB。  
若要求具体有多少种，可利用公式推导得出共有 $2^{k}$ 种可能的二叉树（其中 k 为树中“只有一个孩子的结点”的数量。
![](file-20260228233136922%201.png)

##### 关键点

1. **无法唯一确定的根本原因** 仅凭先序、后序和层序序列中的任意两种组合，通常无法唯一确定一棵二叉树。这是因为当某个结点 A **只有一个孩子 B** 时，先序序列（根-子树）为 `A B`，后序序列（子树-根）为 `B A`。此时，完全无法判断 B 到底是 A 的左孩子还是右孩子。

2. **快速求** k **值的秒杀技巧（序列特征）** 在不画图的情况下，可直接通过比对两个序列寻找单分支结点：若在先序序列中存在两个相邻的元素 `...X, Y...`，并且在后序序列中它们恰好**逆序相邻**为 `...Y, X...`，则说明结点 X 只有一个孩子 Y。

3. **计算总数** 在序列中每找到一对满足上述 `(X, Y)` 逆序相邻特征的结点，就统计一次。假设共找到 k 对，则说明树中有 k 个单分支结点。由于每个单分支结点的子树都可以是左子树或右子树（产生 2 种分支），且各结点相互独立，故最终可能的二叉树总数为$2^{k}$种。

#### 由先序序列求出所有可能的中序序列

##### 结论
已知一棵二叉树的先序序列，获取所有可能的中序序列，在本质上完全等价于：**将先序序列作为栈的“入栈序列”，求所有合法的“出栈序列”**。只要符合栈“后进先出（LIFO）”操作特性的出栈序列，就是一种可能的中序序列。

##### 关键点

1. **原理解析（遍历与栈的映射）**：根据二叉树先序遍历和中序遍历的递归算法中递归工作栈的状态变化可以得出结论：二叉树结点的“先序序列”恰好对应着结点被压入栈的次序，而“中序序列”恰好对应着结点从栈中弹出的次序。

2. **数量公式（卡特兰数）**：因为只要确定了入栈次序，所有可能的出栈序列总数即可通过数学公式计算。若先序序列包含 n 个不同的元素，则能构成的可能的中序序列（即合法出栈序列）总数为卡特兰数：n+11​C2nn​。

3. **操作规则**：在求解具体的中序序列时，允许“边入栈边出栈”。例如读到一个先序元素，可以立刻让它入栈并马上出栈（此时它在先序和中序里的位置都靠前）；也可以先连续入栈好几个元素，再依次出栈。这种不同的入栈出栈时机组合，就构成了不同形态的二叉树。