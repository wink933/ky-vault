---
title: 线索二叉树
tags:
  - "#线索二叉树"
date: 2026-02-22
---

---

###  线索二叉树的基本概念


#### 引入
遍历二叉树是按照特定规则将树中所有结点排列成一个线性序列，从而得到相应的遍历序列。在该序列中，除首尾结点外，每个结点都有唯一的**直接前驱和直接后继**。

传统的二叉链表结构仅能反映父子关系，无法直接获取结点在某种遍历序列中的前驱或后继。  

前面提到，在含有 $n$ 个结点的二叉树中，共有 $n+1$ 个空指针域：每个叶结点贡献2个空指针，每个度为1的结点贡献1个空指针，因此空指针总数为 $2n_0+n_1$，又 $n_0=n_2+1$，可得空指针总数为 $n_0+n_1+n_2+1=n+1$。  


由此，自然想到：可否**利用这些空指针，直接指向结点在遍历序列中的前驱或后继**？若能实现，便可像遍历链表一样高效地遍历二叉树，线索二叉树正是基于这一思想设计的。


#### 定义

线索二叉树本质上是利用二叉树中大量闲置的**空指针**，用来存放指向某一种遍历（先序、中序、后序）序列下的前驱和后继结点的指针，从而将二叉树“线性化”以提高遍历效率的数据结构
#### 线索二叉树的规定
具体规定如下：
- 若某结点无左子树，则将 lchild 指向其在指定遍历序列中的前驱结点。
    
- 若某结点无右子树，则将 rchild 指向其在指定遍历序列中的后继结点。
    
- 为区分指针域指向的是孩子还是线索，需在结点结构中增设两个**标志域**，如图 5.16 所示。
    
| lchild | ltag | data | rtag | rchild |
| ------ | ---- | ---- | ---- | ------ |

图 5.16　线索二叉树的结点结构

#### 标志域 ltag 和 rtag 的含义

- ltag=0 表示 lchild 指向左孩子，ltag=1 表示 lchild 指向前驱。
    
- rtag=0 表示 rchild 指向右孩子，rtag=1 表示 rchild 指向后继。
    

#### 结构体定义

```text
typedef struct ThreadNode{
    ElemType data;                 //数据元素
    struct ThreadNode *lchild,*rchild;  //左右孩子指针
    int ltag,rtag;                 //左右线索标志
}ThreadNode,*ThreadTree;
```

采用上述结构的二叉链表称为**线索链表**，其中指向前驱或后继的指针称为**线索**。这种带有线索的二叉树称为线索二叉树。


### 中序线索二叉树的构造

#### 构造过程

**二叉树的线索化是指将二叉链表中的空指针域替换为指向前驱或后继的线索。**    

由于结点的前驱和后继关系只能在遍历过程中确定，因此线索化本质上就是对二叉树进行一次遍历。

以中序线索二叉树的构造为例：设指针 pre 指向**刚刚访问过的结点**，指针 p 指向当**前正在访问的结点**，pre 即为 p 的中序前驱。在中序遍历过程中：检查 p 的左指针是否为空，若为空则令其指向 pre；检查 pre 的右指针是否为空，若为空则令其指向 p，如图 5.17 所示。

![](assets/线索二叉树/file-20260223201921494.png)

#### 算法分析

```text
void InThread(ThreadTree p,ThreadTree &pre){
    if(p!=NULL){
        InThread(p->lchild,pre);           //递归，线索化左子树
        if(p->lchild==NULL){              //当前结点的左子树为空
            p->lchild=pre;                //建立当前结点的前驱线索
            p->ltag=1;
        }
        if(pre!=NULL&&pre->rchild==NULL){ //前驱结点非空且其右子树为空
            pre->rchild=p;                //建立前驱结点的后继线索
            pre->rtag=1;
        }
        pre=p;                            //标记当前结点成为刚刚访问过的结点
        InThread(p->rchild,pre);          //递归，线索化右子树
    }
}
```
• **口诀**：**“p连左，pre连右；连完之后 pre变p”**。（`p` 负责把自己的左指针连到 `pre`，`pre` 负责把自己的右指针连到 `p`，处理完当前结点后，`pre` 紧跟上 `p` 的步伐）。

• **注意** 在 `InThread(ThreadTree p, ThreadTree &pre)` 算法中，`pre` 采用引用传递（`&pre`）是为了在整个递归遍历过程中**全局共享并同步该指针的状态**，确保它始终准确指向“刚刚访问过的最后一个结点”；而 `p` 只是值传递，因为它仅仅代表**当前递归层**所要访问的目标结点，属于局部变量，不需要将其指向的变化反馈给上一层调用。
#### 建树过程

```text
void CreateInThread(ThreadTree T){
    ThreadTree pre=NULL;
    if(T!=NULL){              //非空二叉树，线索化
        InThread(T,pre);      //线索化二叉树
        pre->rchild=NULL;     //处理遍历的最后一个结点
        pre->rtag=1;
    }
}
```

为方便遍历，可在线索链表上增设一个头结点：其 lchild 指向根结点；rchild 指向中序序列的最后一个结点；中序序列的第一个结点的 lchild 和最后一个结点的 rchild 均指向头结点。如此，便形成一个双向循环线索链表，从而支持正向与反向的高效遍历，如图 5.18 所示。

![](assets/线索二叉树/file-20260223202058411.png)

### 中序线索二叉树的遍历

#### 查找结点后继基本操作

中序线索二叉树的结点中已隐含前驱和后继信息，因此遍历时**无须借助栈或递归**。只需先找到中序序列的第一个结点，然后依次查找每个结点的后继，直至后继为空（或回到头结点）。  
在中序线索二叉树中，查找结点后继的规则如下：**若结点的 rtag 为 1，则 rchild 直接指向其后继；若 rtag 为 0，则其后继为右子树中最左下结点（右子树的中序第一个结点）。**

#### 不含头结点的中序线索二叉树遍历相关算法

- **求中序序列中的第一个结点：**

```text
ThreadNode *Firstnode(ThreadNode *p){
    while(p->ltag==0) p=p->lchild;  //沿左孩子链走到最左下结点
    return p;
}
```
>找前驱时对应的是最右下的结点

- **求结点 p 在中序序列中的后继：**

```text
ThreadNode *Nextnode(ThreadNode *p){
    if(p->rtag==0) return Firstnode(p->rchild);  //右子树中最左下结点
    else return p->rchild;                       //若 rtag==1 则直接返回后继线索
}
```


- **利用上面两个算法，可实现非递归的中序遍历：**

```text
void Inorder(ThreadNode *T){
    for(ThreadNode *p=Firstnode(T);p!=NULL; p=Nextnode(p))
        visit(p);
}
```
>时间复杂度为$O(1)$


---

### 先序线索二叉树和后序线索二叉树

建立先序或后序线索二叉树的方法与中序类似，只需调整递归调用顺序及线索建立的位置。以图 5.19(a)的二叉树为例，手工构造先序线索二叉树的过程如下（先序序列为 ABCDF，依次处理每个结点，若其左或右指针为空，则将其替换为对应前驱或后继的线索）：
![](assets/线索二叉树/file-20260224100446530.png)

结点 A、B 均有左右孩子，无须修改指针；结点 C 无左孩子，将其 lchild 指向前驱 B，无右孩子，将其 rchild 指向后继 D；结点 D 无左孩子，将其 lchild 指向前驱 C，无右孩子，将其 rchild 指向后继 F；结点 F 无左孩子，将其 lchild 指向前驱 D，无右孩子且无后继，将其 rchild 置为空，最终得到的先序线索二叉树如图 5.19(b)所示。

构造后序线索二叉树的过程类似（后序序列为 CDBFA）：

结点 C 无左孩子且无前驱，将 lchild 置空，无右孩子，将 rchild 指向后继 D；结点 D 无左孩子，将 lchild 指向前驱 C，无右孩子，将 rchild 指向后继 B；结点 F 无左孩子，将 lchild 指向前驱 B，无右孩子，将 rchild 指向后继 A，得到的后序线索二叉树如图 5.19(c)所示。


**在先序线索二叉树中查找某结点的后继较为直接**：若该结点有左孩子，则左孩子为其后继；若无左孩子但有右孩子，则右孩子为其后继；若为叶结点，则其 rchild 直接指向后继。


**而在后序线索二叉树中查找后继则较为复杂**，需要分以下三种情况：  
① 若结点 x 是整棵二叉树的根，则其后继为空；  
② 若结点 x 是其双亲的右孩子，或是其双亲的左孩子且该双亲无右子树，则 x 的后继即为其双亲；  
③ 若结点 x 是其双亲的左孩子，且该双亲存在右子树，则 x 的后继为该右子树中按后序遍历访问的第一个结点（右子树中最左下结点）。

值得注意的是，图 5.19(c)中，结点 B 的后继是 A，但无法直接通过线索找到后继，需要回溯到其双亲。因此，在后序线索二叉树中高效查找后继通常需要知道结点的父结点信息。为此，通常采用带父指针的三叉链表作为存储结构，而非标准的二叉线索链表。


