---
title: 并查集
tags:
  - "#并查集"
date: 2026-02-25
---
---

5.5.2　并查集

1．并查集的概念

并查集是一种处理不相交集合的合并与查询问题的树状数据结构，它支持三种基本操作：  
1）Initial(S)：将集合 S 中的每个元素都初始化为一个独立的单元素子集合。  
2）Union(S,Root1,Root2)：将集合 S 中的子集合 Root2 并入子集合 Root1。要求 Root1 和 Root2 属于不同的子集合，否则不执行合并操作。  
3）Find(S,x)：在集合 S 中查找单元素 x 所属的子集合，并返回该子集合的根结点。

2．并查集的存储结构

并查集通常采用树的双亲表示法作为其存储结构：每个子集合用一棵树来表示，所有子集合对应的树共同构成一个森林，并统一存储在一个数组中。在该数组中，数组下标代表集合中的元素编号，而每个元素所存的值为其双亲结点的下标；对于根结点，其双亲域设为负数——通常取该子集合元素数量的相反数，既标识其为根，又记录了集合的规模。

例如，设有一个全集合为 $S={0,1,2,3,4,5,6,7,8,9}$，初始化时每个元素自成一个单元素子集合，对应数组中每个位置的值均为 -1，如图 5.28 所示。

---

经过若干合并操作后，这些子集合可能被合并为三个更大的子集合：$S_1={0,6,7,8}$，$S_2={1,4,9}$，$S_3={2,3,5}$，此时并查集的树形及其对应的数组存储形式如图 5.29 所示。

---

要实现两个子集合的并操作（$S_1\cup S_2$），只需将其中一个子集合根结点在数组中的值设为另一个子集合的根结点下标。例如，将 $S_2$ 的根指向 $S_1$ 的根后，所得结构如图 5.30 所示。

---

在该存储方案中，集合元素的编号从 0 到 SIZE-1，其中 SIZE 表示集合中元素的最大数量。

3．并查集的基本实现

并查集的结构定义如下：

```text
#define SIZE 100
int UFSets[SIZE];        //集合元素数组（双亲指针数组）
```


下面是并查集主要运算的实现。

（1）并查集的初始化操作

```text
void Initial(int S[]){             // S 即并查集
    for(int i=0;i<SIZE;i++)        // 每个自成一个单元素集合
        S[i]=-1;
}
```

将每个元素对应的数组值设为-1，表示这些元素各自为根。

（2）并查集的 Find 操作  
在并查集中查找并返回包含元素 x 的树的根。

```text
int Find(int S[],int x){
    while(S[x]>=0)                 //循环寻找 x 的根
        x=S[x];
    return x;                      //根的 S[] 小于 0
}
```

判断两个元素是否属于同一集合，只需分别找到它们的根，再比较根是否相同即可。

（3）并查集的 Union 操作  
合并两个不相交子集合的操作。当要合并两个元素所在的集合时，需要先找到这两个元素的根，然后让一棵子集树的根指向另一棵子集树的根。

```text
void Union(int S[],int Root1,int Root2){
    if(Root1==Root2) return;       //要求 Root1 与 Root2 是不同的集合
    S[Root2]=Root1;                //将根 Root2 连接到另一根 Root1 下面
}
```

Find 和 Union 操作的时间复杂度分别为 $O(d)$ 和 $O(1)$，其中 $d$ 为树的深度。

4．并查集实现的优化

在极端情况下，由 $n$ 个元素构成的集合树可能退化为一条链，深度达到 $n$，此时 Find 操作的最坏时间复杂度为 $O(n)$。改进的方法是：在执行 Union 操作前先比较两个子集合的规模，将规模较小的树作为子树挂到规模较大的树的根下，即“小树并入大树”。为此，可利用根结点的绝对值（其绝对值即为集合大小）来记录该集合中包含的元素个数。

（1）改进的 Union 操作

```text
void Union(int S[],int Root1,int Root2){
    if(Root1==Root2) return;
    if(S[Root2]>S[Root1]){         //Root2 结点数更少
        S[Root1]+=S[Root2];        //累加集合中的元素总数
        S[Root2]=Root1;            //小树合并到大树
    }
    else{
        S[Root2]+=S[Root1];        //Root1 结点数更少
        S[Root1]=Root2;            //小树合并到大树
    }
}
```

采用这种按集合大小合并的策略后，所构造的集合树深度不超过 $\log_2 n + 1$。然而，随着子集不断合并，集合树的深度仍可能逐渐增大。为进一步缩短查找时间，还可对上述 Find 操作进一步优化：引入路径压缩机制——在找到根结点后，将从 x 到根路径上的所有中间结点直接连接到根结点下，从而“压平”整条路径。

（2）改进的 Find 操作

```text
int Find(int S[],int x){
    int root=x;
    while(S[root]>=0)              //循环找到根
        root=S[root];
    while(x!=root){                //压缩路径
        int t=S[x];                //t 指向 x 的父结点
        S[x]=root;                 //x 直接连到根结点下面
        x=t;
    }
    return root;                   //返回根结点编号
}
```

采用按大小合并与路径压缩两种优化后，并查集的操作效率得到极大提升，使得集合树的深度不超过 $O(\alpha(n))$，其中 $\alpha(n)$ 是一个增长极其缓慢的函数，对于常见的正整数 $n$，通常 $\alpha(n)\le 4$。

### 并查集

#### 概念
并查集是一种处理不相交集合的合并与查询问题的树状数据结构，它支持三种**基本操作**：  
   - `Initial(S)`：将集合 S 中的每个元素都初始化为一个独立的单元素子集合。
   - `Union(S, Root1, Root2)`：将集合 S 中的子集合 Root2 并入子集合 Root1。要求 Root1 和 Root2 属于不同的子集合，否则不执行合并操作。
   - `Find(S, x)`：在集合 S 中查找单元素 x 所属的子集合，并返回该子集合的根结点。

#### 存储结构
- 并查集通常采用树的双亲表示法作为其存储结构：
  - 每个子集合用一棵树来表示，所有子集合共同构成一个森林。
  - 在数组中，数组下标代表集合中的元素编号，每个元素所存的值为其双亲结点的下标；对于根结点，其双亲域设为负数——通常取该子集合元素数量的相反数。

#### 示例
- 假设全集 $S = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\}$，初始化时每个元素自成一个单元素子集合，对应数组中每个位置的值均为 -1。
  >![](assets/并查集/file-20260225212423702.png)
- 
#### 并查集的基本实现
- **结构定义**：
  ```text
  #define SIZE 100
  int UFSets[SIZE];        // 集合元素数组（双亲指针数组）
  ```

- **初始化操作**：
  ```text
  void Initial(int S[]){
      for(int i=0; i<SIZE; i++)
          S[i] = -1;
  }
  ```

- **Find 操作**：
  ```text
  int Find(int S[], int x){
      while(S[x] >= 0)
          x = S[x];
      return x;
  }
  ```

- **Union 操作**：
  ```text
  void Union(int S[], int Root1, int Root2){
      if(Root1 == Root2) return;
      S[Root2] = Root1;
  }
  ```

#### 并查集的优化
- **改进的 Union 操作**：
  ```text
  void Union(int S[], int Root1, int Root2){
      if(Root1 == Root2) return;
      if(S[Root2] > S[Root1]){
          S[Root1] += S[Root2];
          S[Root2] = Root1;
      }
      else{
          S[Root2] += S[Root1];
          S[Root1] = Root2;
      }
  }
  ```

- **改进的 Find 操作**：
  ```text
  int Find(int S[], int x){
      int root = x;
      while(S[root] >= 0)
          root = S[root];
      while(x != root){
          int t = S[x];
          S[x] = root;
          x = t;
      }
      return root;
  }
  ```

#### 性能优化
- **路径压缩**：在找到根结点后，将从 x 到根路径上的所有中间结点直接连接到根结点下。
- 并查集的操作效率得到极大提升，使得集合树的深度不超过 $O(\alpha(n))$，其中 $\alpha(n)$ 是一个增长极其缓慢的函数。

希望这能帮助你更好地理解和记忆并查集的相关内容！