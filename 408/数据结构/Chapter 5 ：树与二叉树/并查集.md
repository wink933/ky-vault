---
title: 并查集
tags:
  - "#并查集"
date: 2026-02-25
---
---

## 并查集

### 概念
并查集是一种处理不相交集合的合并与查询问题的树状数据结构，它支持三种**基本操作**：
   - `Initial(S)`：将集合 S 中的每个元素都初始化为一个独立的单元素子集合。
   - `Union(S, Root1, Root2)`：将集合 S 中的子集合 Root2 并入子集合 Root1。要求 Root1 和 Root2 属于不同的子集合，否则不执行合并操作。
   - `Find(S, x)`：在集合 S 中查找单元素 x 所属的子集合，并返回该子集合的根结点。


### 逻辑结构
并查集是逻辑结构——集合的一种具体实现，只进行并和查两种操作

### 存储结构

并查集通常采用**树的双亲表示法**作为其存储结构：
- 每个子集合用一棵树来表示，所有子集合共同构成一个森林。
- 在数组中，数组下标代表集合中的元素编号，每个元素所存的值为其双亲结点的下标；对于根结点，其双亲域设为负数——通常取该子集合元素数量的相反数。

### 示例

假设全集 $S = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\}$，初始化时每个元素自成一个单元素子集合，对应数组中每个位置的值均为 -1。
>![](assets/并查集/file-20260225213132437.png)

经过若干合并操作后，这些子集合可能被合并为三个更大的子集合：$S_1 = \{0, 6, 7, 8\}$，$S_2 = \{1, 4, 9\}$，$S_3 = \{2, 3, 5\}$。
>![](assets/并查集/file-20260225213151441.png)

要实现两个子集合的并操作（$S_1\cup S_2$），只需将其中一个子集合根结点在数组中的值设为另一个子集合的根结点下标。例如，将 $S_2$ 的根指向 $S_1$ 的根后，所得结构如图 5.30 所示。
>![](assets/并查集/file-20260225213225881.png)

在该存储方案中，集合元素的编号从 0 到 SIZE-1，其中 SIZE 表示集合中元素的最大数量。

### 并查集的实现

#### 结构定义
```text
#define SIZE 100
int UFSets[SIZE];        // 集合元素数组（双亲指针数组）
```

#### 初始化操作
```text
void Initial(int S[]){
    for(int i=0; i<SIZE; i++)
        S[i] = -1;
}
```
将每个元素对应的数组值设为-1，表示这些元素各自为根。

#### Find 操作
在并查集中查找并返回包含元素 x 的树的根。
```text
int Find(int S[], int x){
    while(S[x] >= 0)
        x = S[x];
    return x;
}
```
判断两个元素是否属于同一集合，只需分别找到它们的根，再比较根是否相同即可。

#### Union 操作
合并两个不相交子集合的操作。
```text
void Union(int S[], int Root1, int Root2){
    if(Root1 == Root2) return;
    S[Root2] = Root1;                // 将根 Root2 连接到另一根 Root1 下面
}
```
Find 和 Union 操作的时间复杂度分别为 $O(d)$ 和 $O(1)$，其中 $d$ 为树的深度。

### 并查集实现的优化

#### 改进的 Union 操作
在极端情况下，由n个元素构成的集合树可能退化为一条链，深度达到n，此时 Find操作的最坏时间复杂度为O（m）。改进的办法是：在执行 Union 操作前先比较两个子集合的规模，将规模较小的树作为子树挂到规模较大的树的根下，即“**小树并入大树**”。为此，可利用**根结点的绝对值**（其绝对值即为集合大小）来记录该集合中包含的元素个数。
```text
void Union(int S[], int Root1, int Root2){
    if(Root1 == Root2) return;
    if(S[Root2] > S[Root1]){         // Root2 结点数更少
        S[Root1] += S[Root2];        // 累加集合中的元素总数
        S[Root2] = Root1;            // 小树合并到大树
    }
    else{
        S[Root2] += S[Root1];        // Root1 结点数更少
        S[Root1] = Root2;            // 小树合并到大树
    }
}
```
采用这种按集合大小合并的策略后，所构造的集合树深度不超过 $\log_2 n + 1$。

#### 改进的 Find 操作
然而，随着子集不断合并，集合树的深度仍可能逐渐增大。为进一步缩短查找时间，还可对上述 Find操作进一步优化：引入**路径压缩机制**——在找到根结点后，将从x到根路径上的所有中间结点直接挂接到根结点下，从而“压平”整条路径。
```text
int Find(int S[], int x){
    int root = x;
    while(S[root] >= 0)
        root = S[root];
    while(x != root){
        int t = S[x];                // t 指向 x 的父结点
        S[x] = root;                 // x 直接连到根结点下面
        x = t;
    }
    return root;
}
```
![](assets/并查集/file-20260225221516023.png)

采用按大小合并与路径压缩两种优化后，并查集的操作效率得到极大提升，使得集合树的深度不超过 $O(\alpha(n))$，其中 $\alpha(n)$ 是一个增长极其缓慢的函数。


