---
title: 并查集
tags:
  - "#并查集"
  - "#树与森林的应用"
date: 2026-02-25
---
---

## 并查集

### 概念
并查集是一种处理不相交集合的合并与查询问题的树状数据结构，它支持三种**基本操作**：
   - `Initial(S)`：将集合 S 中的每个元素都初始化为一个独立的单元素子集合。
   - `Union(S, Root1, Root2)`：将集合 S 中的子集合 Root2 并入子集合 Root1。要求 Root1 和 Root2 属于不同的子集合，否则不执行合并操作。
   - `Find(S, x)`：在集合 S 中查找单元素 x 所属的子集合，并返回该子集合的根结点。


### 逻辑结构
并查集是逻辑结构——集合的一种具体实现，只进行并和查两种操作

### 存储结构

并查集通常采用**树的双亲表示法**作为其存储结构：
- 每个子集合用一棵树来表示，所有子集合共同构成一个森林。
- 在数组中，数组下标代表集合中的元素编号，每个元素所存的值为其双亲结点的下标；对于根结点，其双亲域设为负数——通常取该子集合元素数量的相反数。

### 示例

假设全集 $S = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\}$，初始化时每个元素自成一个单元素子集合，对应数组中每个位置的值均为 -1。
>![](file-20260228234303307%201.png)

经过若干合并操作后，这些子集合可能被合并为三个更大的子集合：$S_1 = \{0, 6, 7, 8\}$，$S_2 = \{1, 4, 9\}$，$S_3 = \{2, 3, 5\}$。
>![](file-20260228234303309.png)

要实现两个子集合的并操作（$S_1\cup S_2$），只需将其中一个子集合根结点在数组中的值设为另一个子集合的根结点下标。例如，将 $S_2$ 的根指向 $S_1$ 的根后，所得结构如图 5.30 所示。
>![](file-20260228234303308%201.png)

在该存储方案中，集合元素的编号从 0 到 SIZE-1，其中 SIZE 表示集合中元素的最大数量。

### 并查集的实现

#### 结构定义
```text
#define SIZE 100
int UFSets[SIZE];        // 集合元素数组（双亲指针数组）
```

#### 初始化操作
```text
void Initial(int S[]){
    for(int i=0; i<SIZE; i++)
        S[i] = -1;
}
```
将每个元素对应的数组值设为-1，表示这些元素各自为根。

#### Find 操作
在并查集中查找并返回包含元素 x 的树的根。
```text
int Find(int S[], int x){
    while(S[x] >= 0)
        x = S[x];
    return x;
}
```
判断两个元素是否属于同一集合，只需分别找到它们的根，再比较根是否相同即可。

#### Union 操作
合并两个不相交子集合的操作。
```text
void Union(int S[], int Root1, int Root2){
    if(Root1 == Root2) return;
    S[Root2] = Root1;                // 将根 Root2 连接到另一根 Root1 下面
}
```
Find 和 Union 操作的时间复杂度分别为 $O(d)$ 和 $O(1)$，其中 $d$ 为树的深度。

### 并查集实现的优化

#### 改进的 Union 操作
在极端情况下，由n个元素构成的集合树可能退化为一条链，深度达到n，此时 Find操作的最坏时间复杂度为O（m）。改进的办法是：在执行 Union 操作前先比较两个子集合的规模，将规模较小的树作为子树挂到规模较大的树的根下，即“**小树并入大树**”。为此，可利用**根结点的绝对值**（其绝对值即为集合大小）来记录该集合中包含的元素个数。
```text
void Union(int S[], int Root1, int Root2){
    if(Root1 == Root2) return;
    if(S[Root2] > S[Root1]){         // Root2 结点数更少
        S[Root1] += S[Root2];        // 累加集合中的元素总数
        S[Root2] = Root1;            // 小树合并到大树
    }
    else{
        S[Root2] += S[Root1];        // Root1 结点数更少
        S[Root1] = Root2;            // 小树合并到大树
    }
}
```
采用这种按集合大小合并的策略后，所构造的集合树深度不超过 $\log_2 n + 1$。

#### 改进的 Find 操作
然而，随着子集不断合并，集合树的深度仍可能逐渐增大。为进一步缩短查找时间，还可对上述 Find操作进一步优化：引入**路径压缩机制**——在找到根结点后，将从x到根路径上的所有中间结点直接挂接到根结点下，从而“压平”整条路径。
```text
int Find(int S[], int x){
    int root = x;
    while(S[root] >= 0)
        root = S[root];
    while(x != root){
        int t = S[x];                // t 指向 x 的父结点
        S[x] = root;                 // x 直接连到根结点下面
        x = t;
    }
    return root;
}
```
![](file-20260228234303308.png)

采用按大小合并与路径压缩两种优化后，并查集的操作效率得到极大提升，使得集合树的深度不超过 $O(\alpha(n))$，其中 $\alpha(n)$ 是一个增长极其缓慢的函数。
>这个$\alpha(n)<\log_{2}^{n}$

### 并查集在不同优化策略下的时间复杂度对比表：

| 并查集实现情况                   | 集合树最坏深度        | `Find` 操作最坏时间复杂度 | `Union` 操作时间复杂度 | 性能说明                                                       |
| ------------------------- | -------------- | ---------------- | --------------- | ---------------------------------------------------------- |
| **基本实现（无优化）**             | n              | O(n)             | O(1)            | 极端情况下（盲目合并），树退化为一条单链表。                                     |
| **优化 Union（按大小合并/小树并大树）** | ⌊log2​n⌋+1     | O(log2​n)        | O(1)            | 利用根结点的绝对值记录集合大小，强制小树连到大树根下，树高严格控制在对数级别。                    |
| **双重优化（按大小合并 + 路径压缩）**    | 极小（不超 O(α(n))） | O(α(n))          | O(1)            | 每次 Find 时顺便将查找路径上的所有结点直接连到根结点，使得操作效率极大提升。α(n) 增长极缓慢，通常 ≤4。 |

### 易错点 / 易混点辨析

#### Union 操作的 O(1) 前提陷阱

   **易错点**：做选择题时，认为“合并任意两个元素所在的集合”只需 O(1) 的时间。

   **辨析**：表中 `Union` 操作的时间复杂度为 O(1) 的**前提是：传入的参数已经是两个集合的根结点**（即 `Root1` 和 `Root2`）。如果在实际应用题中要合并元素 x 和 y 所在的集合，必须先执行两次 `Find` 找到各自的根，此时总耗时实际上是 O(Find)+O(1)。若未加优化，合并两元素的总耗时会退化为 O(n)。

#### “合并后高度=最大高度”的错觉

   **易错点**：直觉上认为合并两棵树，新树的高度天然等于原本最高的那一棵（即误认为无论怎么合都是 max(3,4)=4）。

   **辨析**：只有当两棵树的根作为“平级兄弟”，共同挂在一个**全新的空结点**下时，高度才会是纯粹的 max(h1​,h2​)+1。但在并查集中不分配新结点，必然是一个老根依附于另一个老根，导致**被依附的一方整体下沉一层**。这就决定了“谁依附谁”会直接影响最终的树高。

#### 路径压缩优化的是什么？

   **辨析**：路径压缩（Path Compression）是在执行 **Find** 操作时进行的额外动作。当你在树中向上找根节点时，算法会顺便把这条查找路径上路过的所有结点直接“压平”挂到最终查到的根节点下面。这意味着，第一次 Find 会稍慢，但此后这批结点再进行 Find 操作时，树深变成了 1，直接 O(1) 出结果。

• **关于函数** α(n) **的考法**

   **提示**：在 408 考试中，不需要深究阿克曼函数的反函数 α(n) 的数学推导。只需要知道在**同时采用“按大小合并”和“路径压缩”****常数级时间复杂度**。


