---
title: 二叉树的遍历
tags:
  - "#后序遍历"
  - "#中序遍历"
  - "#先序遍历"
  - "#层次遍历"
date: 2026-02-22
---
---

## 二叉树的遍历

### 定义

二叉树的遍历是指**按照某种搜索路径访问树中的每个结点，使得每个结点均被访问一次且仅被访问一次**。由于二叉树是一种**非线性结构**，每个结点最多有两棵子树，因此需要确定一种系统性的访问顺序，将树中结点排列成一个线性序列，以便于后续处理。

根据二叉树的递归定义，遍历一棵二叉树的关键在于确定对根结点（N）、左子树（L）和右子树（R）的访问顺序。在遵循“先左后右”的原则下，常见的遍历方式有三种：**先序遍历（NLR）、中序遍历（LNR）和后序遍历（LRN）**，其中“序”指的是根结点在遍历序列中的位置。

### 先序遍历（PreOrder）

若二叉树为空，则不执行任何操作；否则，

1. 访问根结点；  
2. 先序遍历左子树；  
3. 先序遍历右子树。

图5.7中的虚线表示对该二叉树进行先序遍历的访问路径，所得先序遍历序列为124635。
![](assets/二叉树的遍历/file-20260222170029477.png)

对应的**递归算法**如下：

```text
void PreOrder(BiTree T){
    if(T!=NULL){
        visit(T);            //访问根结点
        PreOrder(T->lchild); //递归遍历左子树
        PreOrder(T->rchild); //递归遍历右子树
    }
}
```





### 中序遍历（InOrder）

若二叉树为空，则不执行任何操作；否则，

1. 中序遍历左子树；  
2. 访问根结点；  
3. 中序遍历右子树。

图5.8中的虚线表示对该二叉树进行中序遍历的访问路径，所得中序遍历序列为264135。

![](assets/二叉树的遍历/file-20260222170105671.png)

对应的**递归算法**如下：

```text
void InOrder(BiTree T){
    if(T!=NULL){
        InOrder(T->lchild); //递归遍历左子树
        visit(T);           //访问根结点
        InOrder(T->rchild); //递归遍历右子树
    }
}
```


### 后序遍历（PostOrder）

若二叉树为空，则不执行任何操作；否则，

1. 后序遍历左子树；  
2. 后序遍历右子树；  
3. 访问根结点。

图5.9中的虚线表示对该二叉树进行后序遍历的访问路径，所得后序遍历序列为642531。
![](assets/二叉树的遍历/file-20260222170142518.png)
对应的**递归算法**如下：

```text
void PostOrder(BiTree T){
    if(T!=NULL){
        PostOrder(T->lchild); //递归遍历左子树
        PostOrder(T->rchild); //递归遍历右子树
        visit(T);             //访问根结点
    }
}
```

### 总结

上述三种遍历算法中，递归遍历左右子树的顺序都是固定的，**区别仅在于访问根结点的时机不同**。不论采用哪种遍历方法，**每个结点都被访问一次且仅一次**，时间复杂度均为$O(n)$。在递归实现中，**系统工作栈的深度等于树的高度**，在最坏情况下（如单支树），空间复杂度为$O(n)$。

### 层次遍历

图5.10展示了二叉树的层次遍历过程，即按照1，2，3，4的层次顺序，以及箭头所指方向，从上到下、从左到右逐层访问二叉树中的各结点。
![](assets/二叉树的遍历/file-20260222170302787.png)


#### 基本思想

层次遍历需要借助一个队列，其基本思想如下：  
首先将根结点入队，随后不断出队并访问队头结点，同时将其存在的左右孩子依次加入队尾，直至队列为空。

#### 算法分析

二叉树的层次遍历算法如下：

```text
void LevelOrder(BiTree T){
    InitQueue(Q);            //初始化辅助队列
    BiTree p;
    EnQueue(Q,T);            //将根结点入队
    while(!IsEmpty(Q)){      //队列不空则循环
        DeQueue(Q, p);       //队头结点出队
        visit(p);            //访问出队结点
        if(p->lchild!=NULL)
            EnQueue(Q,p->lchild);  //若左孩子不空，则左孩子入队
        if(p->rchild!=NULL)
            EnQueue(Q,p->rchild);  //若右孩子不空，则右孩子入队
    }
}
```

**可将上述层次遍历算法作为一个模板，熟练掌握其执行过程，并达到熟练手写的程度。**

#### 注意

**遍历是二叉树各类操作的基础**。例如，对于一棵给定二叉树，求结点的双亲、查找孩子结点、计算树的深度、统计叶结点数、判断两棵二叉树是否相同等操作，本质上都是在某种遍历过程中完成的。因此，必须深入理解并灵活运用各种遍历方法，以解决实际问题。


### 由遍历序列构造二叉树


对于一棵给定的二叉树，其先序序列、中序序列、后序序列和层序序列都是唯一确定的。然而，仅凭这四种遍历序列中的任意一种，却无法唯一确定这棵二叉树。  
若已知**中序序列**，并辅以其他**三种遍历序列中的任意一种**，则可以唯一地重构出该二叉树。

#### 由先序序列和中序序列构造二叉树


在先序序列中，**第一个结点**必定是整棵二叉树的**根结点**；  
而在中序遍历中，根结点将中序序列划分为两个子序列：左侧子序列为左子树的中序序列，右侧子序列为右子树的中序序列。  
由于左右子树的结点数在先序和中序序列中一致，因此可据此从先序序列中分离出左右子树各自的先序子序列，如图5.11所示。通过递归地对左右子树重复上述过程，即可唯一地确定整棵二叉树。
![](assets/二叉树的遍历/file-20260223110044307.png)
例如，求先序序列（ABCDEFGHI）和中序序列（BCAEDGHFI）所确定的二叉树。  
首先，由先序序列可知A为根结点。  
在中序序列中，A左侧的BC构成左子树的中序序列，右侧的EDGHFI构成右子树的中序序列。  
然后，由先序序列可知B是左子树的根结点，D是右子树的根结点。  
以此类推，将剩余结点递归分解，最终构造出的二叉树如图5.12(c)所示。
![](assets/二叉树的遍历/file-20260223110102273.png)
#### 由后序序列和中序序列构造二叉树

同理，后序序列与中序序列也可唯一确定一棵二叉树。后序序列的最后一个结点即为整棵树的根结点，它同样能将中序序列划分为左右子树的中序序列。随后，根据左右子树的结点数，可从后序序列中分离出对应的左右子树的后序序列，并递归构造，如图5.13所示。
![](assets/二叉树的遍历/file-20260223110125429.png)
请读者分析后序序列（CBEHGIFDA）和中序序列（BCAEDGHFI）所确定的二叉树。

#### 由层序序列和中序序列构造二叉树

在层序序列中，第一个结点必为二叉树的根结点，由此可在中序序列中划分出左右子树的中序序列。若存在左子树，则层序序列的第二个结点一定是左子树的根，可以进一步划分左子树；若存在右子树，则层序序列中紧接着的下一个结点一定是右子树的根，可以进一步划分右子树，如图5.14所示。通过逐层确定各子树的根结点并递归划分，即可唯一确定这棵二叉树。
![](assets/二叉树的遍历/file-20260223110143170.png)
请读者分析层序序列（ABDCEFGIH）和中序序列（BCAEDGHFI）所确定的二叉树。

注意，仅凭先序、后序和层序序列中的任意两种组合，通常无法唯一确定一棵二叉树。例如，图5.15所示的两棵二叉树的先序序列均为AB，后序序列均为BA，层序序列均为AB。
![](assets/二叉树的遍历/file-20260223110159119.png)

