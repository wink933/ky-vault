---
title: 二叉树的遍历
tags:
  - "#后序遍历"
  - "#中序遍历"
  - "#先序遍历"
  - "#层次遍历"
date: 2026-02-22
---
---

## 二叉树的遍历

### 定义

二叉树的遍历是指**按照某种搜索路径访问树中的每个结点，使得每个结点均被访问一次且仅被访问一次**。由于二叉树是一种**非线性结构**，每个结点最多有两棵子树，因此需要确定一种系统性的访问顺序，将树中结点排列成一个线性序列，以便于后续处理。

根据二叉树的递归定义，遍历一棵二叉树的关键在于确定对根结点（N）、左子树（L）和右子树（R）的访问顺序。在遵循“先左后右”的原则下，常见的遍历方式有三种：**先序遍历（NLR）、中序遍历（LNR）和后序遍历（LRN）**，其中“序”指的是根结点在遍历序列中的位置。

### 先序遍历（PreOrder）

若二叉树为空，则不执行任何操作；否则，

1. 访问根结点；  
2. 先序遍历左子树；  
3. 先序遍历右子树。

图5.7中的虚线表示对该二叉树进行先序遍历的访问路径，所得先序遍历序列为124635。
![](assets/二叉树的遍历/file-20260222170029477.png)

对应的**递归算法**如下：

```text
void PreOrder(BiTree T){
    if(T!=NULL){
        visit(T);            //访问根结点
        PreOrder(T->lchild); //递归遍历左子树
        PreOrder(T->rchild); //递归遍历右子树
    }
}
```





### 中序遍历（InOrder）

若二叉树为空，则不执行任何操作；否则，

1. 中序遍历左子树；  
2. 访问根结点；  
3. 中序遍历右子树。

图5.8中的虚线表示对该二叉树进行中序遍历的访问路径，所得中序遍历序列为264135。

![](assets/二叉树的遍历/file-20260222170105671.png)

对应的**递归算法**如下：

```text
void InOrder(BiTree T){
    if(T!=NULL){
        InOrder(T->lchild); //递归遍历左子树
        visit(T);           //访问根结点
        InOrder(T->rchild); //递归遍历右子树
    }
}
```


### 后序遍历（PostOrder）

若二叉树为空，则不执行任何操作；否则，

1. 后序遍历左子树；  
2. 后序遍历右子树；  
3. 访问根结点。

图5.9中的虚线表示对该二叉树进行后序遍历的访问路径，所得后序遍历序列为642531。
![](assets/二叉树的遍历/file-20260222170142518.png)
对应的**递归算法**如下：

```text
void PostOrder(BiTree T){
    if(T!=NULL){
        PostOrder(T->lchild); //递归遍历左子树
        PostOrder(T->rchild); //递归遍历右子树
        visit(T);             //访问根结点
    }
}
```

### 总结

上述三种遍历算法中，递归遍历左右子树的顺序都是固定的，**区别仅在于访问根结点的时机不同**。不论采用哪种遍历方法，**每个结点都被访问一次且仅一次**，时间复杂度均为$O(n)$。在递归实现中，**系统工作栈的深度等于树的高度**，在最坏情况下（如单支树），空间复杂度为$O(n)$。

### 层次遍历

图5.10展示了二叉树的层次遍历过程，即按照1，2，3，4的层次顺序，以及箭头所指方向，从上到下、从左到右逐层访问二叉树中的各结点。
![](assets/二叉树的遍历/file-20260222170302787.png)


#### 基本思想

层次遍历需要借助一个队列，其基本思想如下：  
首先将根结点入队，随后不断出队并访问队头结点，同时将其存在的左右孩子依次加入队尾，直至队列为空。

#### 算法分析

二叉树的层次遍历算法如下：

```text
void LevelOrder(BiTree T){
    InitQueue(Q);            //初始化辅助队列
    BiTree p;
    EnQueue(Q,T);            //将根结点入队
    while(!IsEmpty(Q)){      //队列不空则循环
        DeQueue(Q, p);       //队头结点出队
        visit(p);            //访问出队结点
        if(p->lchild!=NULL)
            EnQueue(Q,p->lchild);  //若左孩子不空，则左孩子入队
        if(p->rchild!=NULL)
            EnQueue(Q,p->rchild);  //若右孩子不空，则右孩子入队
    }
}
```

**可将上述层次遍历算法作为一个模板，熟练掌握其执行过程，并达到熟练手写的程度。**

#### 注意

**遍历是二叉树各类操作的基础**。例如，对于一棵给定二叉树，求结点的双亲、查找孩子结点、计算树的深度、统计叶结点数、判断两棵二叉树是否相同等操作，本质上都是在某种遍历过程中完成的。因此，必须深入理解并灵活运用各种遍历方法，以解决实际问题。

