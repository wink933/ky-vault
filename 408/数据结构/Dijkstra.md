---

topic: "Dijkstra（单源最短路）"  
module: "图"  
tags:

- "#Dijkstra"
    
- "#最短路"
    
- "#松弛"
    
- "#贪心"
    
- "#优先队列"
    
- "#邻接表"  
exam_weight: "高"  
one_liner: "用“已确定集合S+反复松弛”在非负权图里逐步锁定单源最短路"  
updated: "2026-01-23"
    

---

> [!summary] 🧠 概念卡｜Dijkstra（图）
> 
> - 核心得分点：维护两类点：**S=已确定最短路**、V−S=未确定；每次选**dist最小**的未确定点加入S
>     
> - 关键操作：**松弛 Relax**：若`dist[u]+w(u,v) < dist[v]`则更新`dist[v]`与`pre[v]`
>     
> - 必背前提：**边权非负**（否则“先确定的点”可能被负边翻盘）
>     
> - 常考输出：给图+源点 → 写出每轮`S、dist[]、pre[]`或最终最短距离/路径
>     
> - 常考实现：邻接矩阵O(|V|^2)；邻接表+堆O((|V|+|E|)log|V|)
>     

> [!note] 🎯 为什么需要（只写“问题与动机”，不写定义）
> 
> - 单源到多点：一次求出源点到所有点的最短距离（以及路径）
>     
> - 手推题常见：比BFS更一般（带权），但又比Bellman-Ford更快（在非负权前提下）
>     
> - 工程动机：路由/导航类问题常是**非负代价**，适配Dijkstra“逐步锁定”策略
>     

> [!info] 🔗 机制链条（背诵版｜结构清晰）
> 
> - 触发(单源最短路；边权非负；要距离+可选路径)
>     
> - → 输入(源点s；图G(V,E,w≥0)；存储：矩阵或邻接表)
>     
> - → 核心步骤〔初始化dist；循环：选未确定中dist最小的u加入S；对u的出边做松弛更新dist/pre〕
>     
> - → 输出〔dist[v]=s到v最短距离；pre[v]用于回溯最短路径〕
>     
> - → 副作用/代价〔时间：矩阵O(|V|^2)；堆优化O((|V|+|E|)log|V|)；空间：O(|V|+|E|)；性质：贪心、非负权正确〕
>     
> - → 失败/异常分支〔存在负权边→结果不保证正确；不连通→部分dist=∞；实现未处理“无可选u”→循环出错〕
>     

> [!tip] 🧭 流程/状态机（伪图示｜画关键分支）
> 
> ```text
> 初始化：
>   S = ∅
>   dist[s]=0；其余dist=∞
>   pre[*]=NIL
> 循环（重复 |V| 次 或直到所有可达点确定）：
>   1) 选择：u = argmin_{v∉S} dist[v]
>      - 若 dist[u]==∞：break（剩余点不可达）
>   2) 确定：S = S ∪ {u}   （u 的最短路“锁定”）
>   3) 松弛（关键分支）：
>      对每条边 (u,v,w) 且 v∉S：
>        if dist[u] + w < dist[v]:
>             dist[v] = dist[u] + w
>             pre[v] = u
> 
> 【两大考点分支】
>   - “已确定集合S”一旦加入：u不再被更新（依赖 w≥0）
>   - “松弛更新”只会让dist变小，且通常同步更新pre用于还原路径
> ```

> [!abstract] 🧾 最小对比表（只保留能得分的维度）
> 
> |算法|适用权值|输出范围|主要机制|典型复杂度|
> |---|---|---|---|---|
> |Dijkstra|w≥0|单源到全体|选最小dist入S + 松弛|矩阵O(V^2)；堆O((V+E)logV)|
> |Bellman-Ford|可含负边（无负环）|单源到全体|反复松弛E边共V-1轮|O(VE)|
> |Floyd|可含负边（无负环）|任意两点|DP：中间点逐步放开|O(V^3)|

> [!question] 🧩 真题命题信号词 → 直接定位
> 
> - “**单源最短路**”“**非负权**”“**贪心选最小dist**” → Dijkstra模板题
>     
> - “写出每一轮的**S集合/确定顶点顺序**” → 重点：**选点顺序 + 松弛结果**
>     
> - “要求输出**最短路径本身**” → 必须维护`pre[]`并回溯
>     
> - “出现**负权边/负环**” → 直接转向Bellman-Ford（Dijkstra不保正确）
>     
> - “稀疏图/大图”暗示：邻接表+堆优化；“稠密图”暗示：矩阵O(V^2)更合适
>     

> [!warning] ⚠ 易错点清单（带自检）
> 
> -  没检查权值前提：图里有负边还硬套Dijkstra？
>     
> -  把“已确定”的点又拿去松弛更新（或允许其dist再变小）→ 破坏S不变量
>     
> -  选u时没处理`dist[u]==∞`：导致把不可达点也“确定”并继续乱松弛
>     
> -  松弛只更新dist不更新pre：最后路径还原写不出来
>     
> -  有向图/无向图边集处理错：无向边要当成两条有向边松弛
>     
> -  堆实现忘了处理“旧键”问题（多次入堆）导致重复处理（需判`visited`或比对dist）
>     

> [!success] ✅ 可直接套用的答题骨架（选择/简答/算法题通用）
> 
> - **不变量一句话**：任意时刻`S`中顶点的`dist`已是最短；`dist[v]`始终是“当前已知的最短上界”
>     
> - **手推题作答模板**：
>     
>     - 1. 初始化写`dist`（源点0，其余∞），`S=∅`
>             
>     - 2. 每轮写：选`u`（未入S且dist最小）→ 加入S → 对u邻接点逐条松弛并更新dist/pre
>             
>     - 3. 输出：`dist[]`最终值 + 需要路径则从终点按`pre`回溯到源点
>             
> - **伪码骨架（矩阵版）**：外层V次找min（O(V)）+ 内层遍历所有v做松弛（O(V)）
>     
> - **防错口令**：先判**非负权**；选点后立刻“入S锁定”；松弛时同步写`pre`
>     

> [!quote] 🔗 知识网络（双链串题）
> 
> - [[图的存储结构]]：[[邻接矩阵]] vs [[邻接表]]
>     
> - [[最短路径]]：单源 vs 全源
>     
> - [[BFS]]：无权图最短路（Dijkstra的“非负权推广”对照）
>     
> - [[Bellman-Ford]]：含负边的单源最短路
>     
> - [[Floyd]]：任意两点最短路
>     
> - [[优先队列与堆]]：堆优化Dijkstra的核心
>     
> - [[贪心算法]]：Dijkstra正确性依赖的策略框架
>     
> - [[路径回溯pre数组]]：输出“最短路径序列”的必备组件
>     

- **堆优化关键点**：用优先队列按`dist`取最小；松弛成功就把(v,dist[v])入堆。若无Decrease-Key，允许重复入堆，出堆时用`visited[v]`或“弹出键是否等于当前dist[v]”过滤旧条目。
    
- **路径还原**：从终点t开始反复`t=pre[t]`直到s，逆序得到路径；不可达则`dist[t]=∞`且`pre`链断。
    
- **复杂度速记**：稠密图E≈V^2→矩阵O(V^2)很合适；稀疏图E≈V→堆优化更占优。