---
title: 算法和算法评价
tags:
  - "#算法"
categories:
date: 2026-02-07
---

---

### 算法的基本概念

##### **定义**
> 描述：算法(Algorithm)是对特定问题**求解步骤的描述**，是一个**有穷的指令序列**，其中每一条指令表示一个或多个操作。
> 此外，一个有效的算法还应该具备以下五个重要特性。

- 有穷性：算法必须在执行有限步后结束，且每一步都能在有限时间内完成
  >算法必须是有穷的，而程序可以是无穷的
- 确定性：算法中的每条指令必须有明确的含义，对于相同的输入，只能产生相同的输出
  >必须保证无歧义
- 可行性：算法中描述的操作都可以通过已实现的基本运算执行有限次来完成
- 输入：算法可以有零个或多个输入，这些输入取自某个特定对象的集合
- 输出：算法至少有一个输出，且该输出与输入之间存在某种特定关系
  
  >联想到数学中的函数$y=f(x)$，其中x就表示输入，f代表算法，表示映射关系，y就代表输出


##### **好算法应该满足的特质**

- 正确性：能够正确地解决所给问题。

- 可读性：结构清晰、易于理解，便于阅读和交流。

- 健壮性：对非法或异常输入能做出适当处理，而不是产生不可预测的结果。

- 高效率与低存储量需求：效率是指算法的执行时间，存储量需求是指执行过程中所需的最大存储空间，二者均与问题规模密切相关。



### 算法效率的度量

#### 时间复杂度
##### **定义**
> 描述：时间复杂度描述算法执行时间随问题规模n增大而变化的趋势，是关于n的渐近函数。

##### **理解**
>设算法中所有语句的频段之和为$T(n)$
- 算法执行时间通常是由语句频段或者说是某条语句的执行次数来衡量
- 在n足够大时，低阶项和常数系数对整体增长趋势的影响可以忽略不计，因此只需关注$T(n)$中**增长最快的项**
- 时间复杂度通常用大O记号表示：若存在正常数C和$n_0$，使得对所有的$n\ge n_0$时，都有$$0\le T(n)\le Cf(n)$$
  则称$T(n)=O(f(n))$，表示在n足够大时，$T(n)$的增长速度不超过$f(n)$的常数倍
- 算法的实际运行时间不仅依赖于问题规模n，还受输入数据初始状态的影响
- 通常用最坏时间复杂度作为算法效率的评价标准，因为它提供了运行时间的确定性上界

##### **规则**

> 1）加法规则，若两段代码顺序执行，则总时间复杂度取两者中的高阶项：  
> $$O(f(n))+O(g(n))=O(\max(f(n),g(n)))$$
> 
> 2）乘法规则，若一段代码嵌套在另一段内部中，则总时间复杂度为两者之积：  
> $$O(f(n))\cdot O(g(n))=O(f(n)g(n))$$

> 常见的时间复杂度阶次（按增长速度升序）：  
> $$O(1)<O(\log_2 n)<O(n)<O(n\log_2 n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$$
> **常对幂指阶**

##### **结论**

1. 顺序执行的代码只会影响常数项，可以忽略
2. 只需跳循环中的一个基本操作分析它的执行次数与n的关系即可 
3. 如果有多层嵌套循环，那么只需关注最深层循环循环了几次


##### **三种时间复杂度**

- 最坏时间复杂度
  >输入数据的情况最坏
- 平均时间复杂度
  >所有输入数据等概率出现
- 最好时间复杂度
  >输入数据的情况最好


#### 空间复杂度
##### **定义**
> 描述：空间复杂度$S(n)$表示算法在运行过程中所需的额外存储空间，是问题规模n的函数，记为$$S(n)=O(g(n))$$

##### **理解**
- 输入数据所占的空间只取决于问题本身，不计入空间复杂度
- 指令、常数以及与n无关的变量所占的空间为固定开销，不随问题规模而变化
- 只需关注算法额外使用的辅助空间，若额外空间为常量级，则称其为原地工作，时间复杂度为$O(1)$






