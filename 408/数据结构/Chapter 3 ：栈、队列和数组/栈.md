---
title: 栈
tags:
  - "#栈"
  - "#共享栈"
date: 2026-02-19
---
---

## 栈的基本概念

### 栈的定义

栈（Stack）是仅允许在**一端**进行插入和删除操作的线性表。作为一种特殊的线性表，栈的插入（入栈）和删除（出栈）操作被限制在表的一端进行，如图所示。

![](assets/栈/file-20260219221234525.png)

- 栈顶（Top）：允许进行插入和删除操作的一端。  
- 栈底（Bottom）：固定不变、不允许进行插入和删除操作的另一端。  
- 空栈：不含任何元素的栈。

假设某栈 $S=(a_1,a_2,a_3,a_4,a_5)$，如上图所示，其中 $a_1$ 为栈底元素，$a_5$ 为栈顶元素。栈的入栈和出栈操作只能在栈顶进行。若元素按顺序 $a_1,a_2,a_3,a_4,a_5$ 入栈，则出栈顺序为 $a_5,a_4,a_3,a_2,a_1$。由此可见，栈的操作特性可概括为**后进先出**（Last In First Out，LIFO）。

### 栈的基本操作


```text
• InitStack(&S)：初始化一个空栈 S。
• StackEmpty(S)：判断栈是否为空。若栈 S 为空，返回 true；否则返回 false。
• Push(&S,x)：入栈操作；若栈未满，则 x 成为新的栈顶元素。
• Pop(&S,&x)：出栈操作；若栈非空，则弹出栈顶元素，并通过 x 返回该值。
• GetTop(S,&x)：读取栈顶元素但不出栈；若栈非空，则通过 x 返回栈顶元素。
• DestroyStack(&S)：销毁栈 S，并释放其所占用的存储空间（&表示引用调用）。
```

在解答算法题时，若题目未作特殊限制，可直接使用上述基本操作函数。


### 栈的数学性质
当 $n$ 个不同元素按固定次序入栈时，可能的出栈序列总数为 $\frac{1}{n+1}C_{2n}^{n}$。该数列称为**卡特兰（Catalan）数**，可通过数学归纳法证明。


## 栈的顺序存储结构

### 顺序栈的实现

#### 顺序栈定义

采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放从栈底到栈顶的数据元素，并附设一个整型指针（top）指示当前栈顶元素的位置。

#### 结构体定义

```text
#define MaxSize 50            //定义栈中元素的最大个数
typedef struct{
    Elemtype data[MaxSize];   //存放栈中元素
    int top;                  //栈顶指针
}SqStack;
```

- **栈顶指针**：`S.top`，初始时设为 S.top=-1；栈顶元素：S.data[S.top]。  
- **入栈操作**：当栈未满时，先将栈顶指针加 1，再将元素存入栈顶。  
- **出栈操作**：当栈非空时，先取出栈顶元素，再将栈顶指针减 1。  
- **栈空条件**：`S.top==-1`；栈满条件：`S.top==MaxSize-1`；栈长：S.top+1。

另一种常见的方式是：栈顶指针初始化为 S.top=0；入栈时先将元素存入栈顶，再将栈顶指针加 1；出栈时先将栈顶指针减 1，再取出栈顶元素；栈空条件为 `S.top==0`；栈满条件为  `S.top==MaxSize`。


顺序栈的入栈操作受数组上界约束。若对栈的最大使用空间估计不足，则可能发生**栈上溢**，此时，应向用户报告错误信息，以便及时处理，避免程序异常。



### 顺序栈的基本操作

#### 注意
栈和队列的判空、判满条件，会因实际给出的条件不同而变化，下面的代码实现是在栈顶指针初始化为 -1 的条件下的相应方法，而其他情况则需具体问题具体分析。


#### 栈操作的示意图  
图3.2(a)为空栈，图3.2(c)为A、B、C、D、E依次入栈后的状态，图3.2(d)为在图3.2(c)基础上E、D、C相继出栈后的结果，此时栈中剩余2个元素。尽管C、D、E可能仍保留在原存储单元中，但top指针已指向新的栈顶，因此它们已不属于当前栈的内容。读者应结合该图理解栈顶指针的作用：它标识了栈中有效元素的边界。
![](assets/栈/file-20260219224122882.png)

#### 基本操作
以下是顺序栈常用基本操作的实现（基于top=-1初始化）。

##### 初始化

```text
void InitStack(SqStack &S){
    S.top=-1;            //初始化栈顶指针
}
```

##### 判栈空

```text
bool StackEmpty(SqStack S){
    if(S.top==-1)
        return true;     //栈空
    else
        return false;    //不空
}
```

##### 入栈

```text
bool Push(SqStack &S,ElemType x){
    if(S.top==MaxSize-1) //栈满，报错
        return false;
    S.data[++S.top]=x;   //指针先加1，再入栈
    return true;
}
```

##### 出栈

```c++
bool Pop(SqStack &S,ElemType &x){
    if(S.top==-1)        //栈空，报错
        return false;
    x=S.data[S.top--];   //先出栈，指针再减1
    return true;
}
```


##### 读栈顶元素

```text
bool GetTop(SqStack S,ElemType &x){
    if(S.top==-1)        //栈空，报错
        return false;
    x=S.data[S.top];     //x记录栈顶元素
    return true;
}
```

>该操作不改变栈的状态，栈顶元素依然保留在栈中。

## 共享栈

### 共享栈的定义

利用栈底位置相对固定的特性，可让两个顺序栈共享同一段一维数组空间，将两个栈的栈底分别置于数组两端，栈顶向中间延伸，如图3.3所示。

![](assets/栈/file-20260219224539340.png)

### 操作说明
0号栈栈顶指针为top0，1号栈栈顶指针为top1，均指向各自的栈顶元素；初始时top0=-1（0号栈空），top1=MaxSize（1号栈空）；栈满条件为`top1-top0==1`（两栈顶相邻）。当0号栈入栈时，top0先加1，再赋值；当1号栈入栈时，top1先减1，再赋值；出栈操作的顺序相反。

### 共享栈的优势
共享栈能更高效地利用存储空间，两个栈的空间可动态调节，仅当整个数组被占满时，才发生**栈溢出**。其存取数据的时间复杂度均为O(1)，对存取效率无影响。