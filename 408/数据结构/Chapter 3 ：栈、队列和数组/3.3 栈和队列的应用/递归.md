---
title: 递归
tags:
  - "#递归"
date: 2026-02-28
---
---

## 栈在递归中的应用

### 函数调用的特点

最后被调用的函数，最先执行结束(LIFO)

### 函数调用栈
函数调用时需要一个栈来存储：  
调用返回地址  
实参  
局部变量
![](file-20260228234603219.png)
递归的空间复杂度往往来自**调用栈深度**，深度为 `d` 则额外空间约 `O(d)`。
### 递归

递归是一种重要的程序设计方法。简单来说，若一个函数。过程或数据结构在其定义中直接或间接地引用了自身，则称其为递归定义，简称递归。递归通过将原问题逐层分解为规模更小但结构相同的子问题来求解。借助递归策略，仅需少量代码即可简洁地表达解题过程中反复出现的相同计算模式，显著减少程序代码量。然而，在一般情况下，递归的执行效率并不高，因为递归算法在计算机执行过程中包含很多的重复计算，所以效率会低

以斐波那契数列为例，其数学定义为

$$F(n)=\begin{cases}  
F(n-1)+F(n-2),\ n>1\  
1,\qquad\qquad\qquad\ \ n=1\  
0,\qquad\qquad\qquad\ \ n=0  
\end{cases}$$

这是递归的典型范例，其程序实现如下：

```text
int F(int n){                  //斐波那契数列的实现
    if(n==0)
        return 0;              //边界条件
    else if(n==1)
        return 1;              //边界条件
    else
        return F(n-1)+F(n-2);  //递归表达式
}
```

必须注意，递归定义不能是循环或无终止的，必须满足以下两个条件：

- **递归体**（递归表达式）：描述问题如何分解为更小规模的同类子问题。
    

- **边界条件**（递归出口）：确保递归在有限步内终止。  
    递归的精髓在于能否将原问题转化为属性相同但规模更小的问题。



---
