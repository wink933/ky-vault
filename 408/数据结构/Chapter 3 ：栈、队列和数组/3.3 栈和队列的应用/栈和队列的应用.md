---
title: 栈和队列的应用
tags:
  - "#括号匹配"
  - "#表达式求值"
date: 2026-02-20
---
---



## 栈在递归中的应用

### 函数调用的特点

最后被调用的函数，最先执行结束(LIFO)

### 函数调用栈
函数调用时需要一个栈来存储：  
调用返回地址  
实参  
局部变量
![](file-20260228234603219.png)
递归的空间复杂度往往来自**调用栈深度**，深度为 `d` 则额外空间约 `O(d)`。
### 递归

递归是一种重要的程序设计方法。简单来说，若一个函数。过程或数据结构在其定义中直接或间接地引用了自身，则称其为递归定义，简称递归。递归通过将原问题逐层分解为规模更小但结构相同的子问题来求解。借助递归策略，仅需少量代码即可简洁地表达解题过程中反复出现的相同计算模式，显著减少程序代码量。然而，在一般情况下，递归的执行效率并不高，因为递归算法在计算机执行过程中包含很多的重复计算，所以效率会低

以斐波那契数列为例，其数学定义为

$$F(n)=\begin{cases}  
F(n-1)+F(n-2),\ n>1\  
1,\qquad\qquad\qquad\ \ n=1\  
0,\qquad\qquad\qquad\ \ n=0  
\end{cases}$$

这是递归的典型范例，其程序实现如下：

```text
int F(int n){                  //斐波那契数列的实现
    if(n==0)
        return 0;              //边界条件
    else if(n==1)
        return 1;              //边界条件
    else
        return F(n-1)+F(n-2);  //递归表达式
}
```

必须注意，递归定义不能是循环或无终止的，必须满足以下两个条件：

- **递归体**（递归表达式）：描述问题如何分解为更小规模的同类子问题。
    

- **边界条件**（递归出口）：确保递归在有限步内终止。  
    递归的精髓在于能否将原问题转化为属性相同但规模更小的问题。



---

## 队列的应用
### 队列在层次遍历中的应用

#### 常用策略

在信息处理中，有一类典型问题需要逐层或逐行处理。解决这类问题的常用策略是：在处理当前层的同时，将下一层的元素按序加入待处理队列。队列正适用于此类场景，因其先进先出的特性，能够自然地保存后续待处理元素的顺序。以二叉树的层次遍历为例（见图 3.17），可清晰体现队列的应用价值。表 3.3 展示了该遍历过程的具体执行步骤。
![](file-20260228234603217.png)
![](file-20260228234603220.png)

#### 基本过程

该过程可简要描述如下：  
① 将根结点入队。  
② 若队列为空（表示所有结点均已处理），则遍历结束；否则执行③。  
③ 取出队首结点并访问；若其存在左孩子，则将左孩子入队；若其存在右孩子，则将右孩子入队；返回②继续执行。

### 队列在计算机系统中的应用

队列在计算机系统中的应用非常广泛，以下从两个主要方面进行阐述：第一个方面是解决主机与外部设备之间速度不匹配的问题，第二个方面是解决由多用户引起的资源竞争问题。

#### 打印机缓冲区

以主机和打印机之间的速度不匹配为例。主机输出数据的速度远快于打印机处理数据的速度。若直接将数据发送给打印机，会导致数据丢失或打印错误。为此，通常设置一个打印数据缓冲区来缓解这一问题。具体实现如下：主机将待打印的数据依次写入缓冲区，当缓冲区满时，主机暂停输出并转向其他任务；打印机则从缓冲区中按先进先出原则逐个取出数据进行打印；打印完成后，打印机向主机发出请求，主机再次向缓冲区写入新的打印数据。这种方法不仅保证了数据的正确性，还提高了主机的整体效率。因此，打印数据缓冲区实际上就是一个队列。

#### CPU调度（FCFS）

在多用户环境下，CPU 资源的竞争是一个典型场景。在一个多终端系统中，用户通过各自的终端向操作系统提出对 CPU 的请求。为公平分配 CPU 时间，操作系统通常按照请求的时间顺序，将这些请求排成一个队列。具体步骤如下：每次将 CPU 分配给队首用户的程序运行；当该程序运行结束或用完规定的时间片后，操作系统使其出队；然后将 CPU 分配给新的队首用户。这种方式既保证了请求的公平处理，又提升了 CPU 利用率。此外，在某些复杂系统中，可能还会引入多队列机制，以便根据不同的优先级或调度策略动态调整资源分配。