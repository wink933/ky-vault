---
title: 栈和队列的应用
tags:
  - "#括号匹配"
  - "#表达式求值"
date: 2026-02-20
---
---

## 栈在括号匹配中的应用

假设表达式中允许包含两种括号：圆括号 `()` 和方括号 `[]`，其嵌套顺序任意。例如，`([]())` 或 `[([][])]` 均为合法格式，而 `[()]`、`([())` 或 `(())` 均为非法格式。

考虑如下括号序列：

```text
[  (  [  ]  [  ]  )  ]
1  2  3  4  5  6  7  8
```

### 分析过程  

1）读入第 1 个括号 “`[`” 后，系统期待与之匹配的 “`]`”（第 8 个）出现。  
2）读入第 2 个括号 “`(`” 后，第 1 个括号 “`[`” 的期待暂时搁置，转而优先期待与 “`(`” 匹配的 “`)`”（第 7 个）出现。  
3）读入第 3 个括号 “`[`”，当前最急迫的期待变为与之匹配的 “`]`”（第 4 个）。该期待满足后，先前被搁置的第 2 个括号 “`(`” 的匹配任务重新成为当前最急迫事项。  
4）以此类推，可见整个处理过程完全符合后进先出的栈行为。

### 算法思想  

1）初始化一个空栈，顺序扫描输入的括号序列。  
2）若遇到左括号，将其压入栈中，表示新增一个待匹配的期待，且其优先级最高。  
3）若遇到右括号，则检查栈是否为空：若栈非空且栈顶左括号与当前右括号匹配，则弹出栈顶，完成一次匹配；否则，括号序列非法，算法终止。  
4）扫描结束后，若栈为空，则括号序列合法；否则，存在未匹配的左括号，序列非法。
>简单来说就是依次扫描所有字符，遇到左括号入栈，遇到右括号则弹出栈顶元素检查是否匹配

### 流程框图

![](assets/栈和队列的应用/file-20260220140200451.png)

### 代码定义

![](assets/栈和队列的应用/file-20260220151632818.png)
## 栈在表达式求值中的应用

### 算数表达式


#### 组成

算数表达式又操作数、运算符、界限符构成

##### 操作数（operand）

参与运算的“对象”，可以是：

- 常量：`3、10、2.5`
    
- 变量/标识符：`a、x、sum`
    
- 更复杂的：数组元素 `a[i]`、函数调用 `f(x)`（在更一般的表达式里）
    

例：`a + b * c` 里 `a、b、c` 都是操作数。


##### 运算符（operator）

表示“做什么运算”的符号/关键字。

- 算术：`+ - * / %`
    
- 关系：`< <= > >= == !=`
    
- 逻辑：`&& || !`
    
- 位运算：`& | ^ ~ << >>`
    
- 赋值：`= += -= ...`
    
- 还有**一元运算符**：如 `-a`（取负）、`!x`（逻辑非）
    

例：`a + b * c` 里 `+、*` 是运算符。

---

##### 界限符（delimiter / separator / boundary symbol）

用来**分隔、界定结构范围**的符号，常见：

- 圆括号：`( )`（最典型：改变运算顺序、界定子表达式）
    
- 方括号：`[ ]`（数组下标）
    
- 花括号：`{ }`（代码块/集合等，取决于语言/语境）
    
- 逗号：`,`（参数/元素分隔）
    
- 分号：`;`（语句结束）
    


#### 算数表达式的分类
##### 中缀表达式（Infix Expression）

**运算符写在两个操作数中间**，人类最习惯的写法。

例：

- `a + b`
    
- `a + b * c`
    
- `(a + b) * c`
    

特点：

- 必须依赖**运算符优先级**与**结合性**，以及括号来消歧义  
    比如 `a + b * c` 默认先算 `b * c`
    

---

##### 前缀表达式（Prefix Expression / Polish Notation）

**运算符写在操作数前面**（波兰表达式）。

例（把中缀 `a + b * c` 改写）：

- 中缀：`a + (b * c)`
    
- 前缀：`+ a * b c`
    

再看一个：

- 中缀：`(a + b) * c`
    
- 前缀：`* + a b c`
    

特点：

- **不需要括号**也能唯一确定运算顺序（在运算符元数固定时，如二元运算符）
    
- 常见求值方式：**从右往左扫描，用栈**（或递归）
    

---

##### 后缀表达式（Postfix Expression / Reverse Polish Notation）

**运算符写在操作数后面**（逆波兰表达式）。

例：

- 中缀：`a + b * c`（即 `a + (b*c)`）
    
- 后缀：`a b c * +`
    

再看一个：

- 中缀：`(a + b) * c`
    
- 后缀：`a b + c *`
    

特点：

- 同样**不需要括号**就能唯一确定运算顺序
    
- 最经典应用：**从左往右扫描，用栈求值**
    
    - 遇到操作数：入栈
        
    - 遇到运算符：弹出所需操作数计算，再把结果入栈
        

---

##### 三者对照速记（同一个表达式）

以中缀：`(a + b) * c` 为例：

- **中缀**：`(a + b) * c`
    
- **前缀**：`* + a b c`
    
- **后缀**：`a b + c *`
    

你可以把它理解成：

- 前缀：**根（运算符）在前**
    
- 后缀：**根（运算符）在后**
    
- 中缀：**根在中间（左右子树夹着）**
    

---

#### 一个常见易错点：一元 `-` vs 二元 `-`

- `-a`：一元运算符（取负）
    
- `a - b`：二元运算符（减法）
    

在前缀/后缀表达式和求值规则里，一元运算符会影响“弹出几个操作数”。


如果你愿意，把你截图里那道“表达式/栈求值/中缀转后缀”的具体题发我，我可以按你考试常用的**扫描+栈变化表**一步一步写出来（这块特别适合固化进 Obsidian）。
### 中缀表达式转后缀表达式

下面先介绍一种手算转换方法。

- 按运算优先级对整个表达式逐层加括号。  
- 将每个运算符移到其所在括号的右括号之后，形成“左操作数 右操作数 运算符”的结构。  
- 删除所有括号，即得后缀表达式。

以 A+B*(C-D)-E/F 为例（下标表示运算顺序）：  
1）加括号：((A+③(B*②(C-①D)))-⑤(E/④F))。  
2）运算符后移：((A(B(CD)-①)_②)+③(EF)/④)-⑤。  
3）去括号后得到后缀表达式：ABCD-①_②+③EF/④-⑤。

在计算机中，该转换过程需借助一个运算符栈，用于暂存尚未确定输出时机的运算符。从左至右依次扫描中缀表达式的每一项，具体规则如下：

- 遇到操作数：直接加入后缀表达式。  
- 遇到界限符：若为“(”，直接入栈；若为“)”，不入栈，且不断弹出栈顶运算符并加入后缀表达式，直到遇到“(”，将其弹出并丢弃。  
- 遇到运算符：① 若其优先级高于栈顶运算符，或栈顶为“(”，则直接入栈；② 若其优先级低于或等于栈顶运算符，则依次弹出栈中运算符并加入后缀表达式，直到栈空，或栈顶为“(”，或遇到优先级更低的运算符为止，再将当前运算符入栈。

按上述方法扫描完所有字符后，将栈中剩余运算符依次弹出并加入后缀表达式。

例如，中缀表达式 A+B*(C-D)-E/F 转后缀表达式的过程如表 3.1 所示。


所谓栈的深度，是指栈中元素最大个数。通常题目会给出入栈和出栈序列，要求计算栈所需的最大容量（最大深度）。有时该信息以中缀与后缀表达式的形式间接提供。掌握栈“后进先出”的特性，并通过手工模拟转换或求值过程，是解决此类问题的有效方法。

### 后缀表达式求值


## 栈在递归中的应用

