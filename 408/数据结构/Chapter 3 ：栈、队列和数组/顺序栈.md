---
title: 顺序栈
tags:
  - "#顺序栈"
  - "#栈上溢"
date: 2026-02-20
---
---
## 栈的顺序存储结构

### 顺序栈的实现

#### 顺序栈定义

采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放从栈底到栈顶的数据元素，并附设一个整型指针（top）指示当前栈顶元素的位置。

#### 结构体定义

```text
#define MaxSize 50            //定义栈中元素的最大个数
typedef struct{
    Elemtype data[MaxSize];   //存放栈中元素
    int top;                  //栈顶指针
}SqStack;
```

- **栈顶指针**：`S.top`，初始时设为 S.top=-1；栈顶元素：S.data[S.top]。  
- **入栈操作**：当栈未满时，先将栈顶指针加 1，再将元素存入栈顶。  
- **出栈操作**：当栈非空时，先取出栈顶元素，再将栈顶指针减 1。  
- **栈空条件**：`S.top==-1`；栈满条件：`S.top==MaxSize-1`；栈长：S.top+1。

另一种常见的方式是：栈顶指针初始化为 S.top=0；入栈时先将元素存入栈顶，再将栈顶指针加 1；出栈时先将栈顶指针减 1，再取出栈顶元素；栈空条件为 `S.top==0`；栈满条件为  `S.top==MaxSize`。


顺序栈的入栈操作受数组上界约束。若对栈的最大使用空间估计不足，则可能发生**栈上溢**，此时，应向用户报告错误信息，以便及时处理，避免程序异常。



### 顺序栈的基本操作

#### 注意
栈和队列的判空、判满条件，会因实际给出的条件不同而变化，下面的代码实现是在栈顶指针初始化为 -1 的条件下的相应方法，而其他情况则需具体问题具体分析。


#### 栈操作的示意图  
图3.2(a)为空栈，图3.2(c)为A、B、C、D、E依次入栈后的状态，图3.2(d)为在图3.2(c)基础上E、D、C相继出栈后的结果，此时栈中剩余2个元素。尽管C、D、E可能仍保留在原存储单元中，但top指针已指向新的栈顶，因此它们已不属于当前栈的内容。读者应结合该图理解栈顶指针的作用：它标识了栈中有效元素的边界。
![](assets/栈/file-20260219224122882.png)

#### 基本操作
以下是顺序栈常用基本操作的实现（基于top=-1初始化）。

##### 初始化

```c++
void InitStack(SqStack &S){
    S.top=-1;            //初始化栈顶指针
}
```

##### 判栈空

```c++
bool StackEmpty(SqStack S){
    if(S.top==-1)
        return true;     //栈空
    else
        return false;    //不空
}
```

##### 入栈

```c++
bool Push(SqStack &S,ElemType x){
    if(S.top==MaxSize-1) //栈满，报错
        return false;
    S.data[++S.top]=x;   //指针先加1，再入栈
    return true;
}
```

##### 出栈

```c++
bool Pop(SqStack &S,ElemType &x){
    if(S.top==-1)        //栈空，报错
        return false;
    x=S.data[S.top--];   //先出栈，指针再减1
    return true;
}
```


##### 读栈顶元素

```c++
bool GetTop(SqStack S,ElemType &x){
    if(S.top==-1)        //栈空，报错
        return false;
    x=S.data[S.top];     //x记录栈顶元素
    return true;
}
```

>该操作不改变栈的状态，栈顶元素依然保留在栈中。