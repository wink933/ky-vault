

## 001



> [!question] 题干
> 链式存储设计时，结点内的存储单元地址是否连续

> [!success] 解析
> 一定连续，注意题干中说的是结点内，如果是各个不同结点之间可以不连续，但是结点内一定是连续的

> [!note] 总结
> 
##### **知识关联**
- 



## 002



> [!question] 题干
> 链式存储结构比顺序存储结构能更方便的表示各种逻辑结构

> [!success] 解析
> 链式存储用指针表示逻辑结构，而指针的设置是任意的，因此链式存储能更方便的表示逻辑结构

> [!note] 总结
> 
##### **知识关联**
- [[存储与存取#为什么链式存储结构比顺序存储结构能更加方便的表示各种逻辑结构]]



## 003



> [!question] 题干
> 11. 下列说法中，正确的是（ ）。
A. 消除递归不一定需要使用栈  
B. 对同一输入序列进行两组不同的合法入栈和出栈组合操作，所得的输出序列也一定相同  
C. 通常使用队列来处理函数或过程调用  
D. 队列和栈都是运算受限的线性表，只允许在线性表的两端进行运算


> [!success] 解析
> 使用栈可以模拟递归的过程，以此来消除递归，但对于单向递归和尾递归而言，可以用迭代的方式来消除递归，选项 A 正确。不同的入栈和出栈组合操作，会产生许多不同的输出序列，B 错误。通常使用栈来处理函数或过程调用，选项 C 错误。队列和栈都是操作受限的线性表，但只有队列允许在表的两端进行运算，而栈只允许在栈顶方向进行操作，选项 D 错误。

> [!note] 总结
> 
##### **知识关联**
- [[栈和队列的应用#函数调用栈]]



## 004



> [!question] 题干
> 27. 二叉树在线索化后，仍不能有效求解的问题是（ ）。
>
A. 先序线索二叉树中求先序后继  
B. 中序线索二叉树中求中序后继  
C. 中序线索二叉树中求中序前驱  
D. 后序线索二叉树中求后序后继

> [!success] 解析
> 

> [!note] 总结
> 
##### **知识关联**
- [[线索二叉树]]


## 005



> [!question] 题干
> 若 X 是二叉中序线索树中一个有左孩子的结点，且 X 不为根，则 X 的前驱为（ ）。
>
A. X 的双亲  
B. X 的右子树中最左的结点  
C. X 的左子树中最右的结点  
D. X 的左子树中最右的叶结点



> [!success] 解析
> 

> [!note] 总结
> 
##### **知识关联**
- [[线索二叉树]]



## 006



> [!question] 题干
> 【2022 统考真题】若结点 $p$ 与 $q$ 在二叉树 $T$ 的中序遍历序列中相邻，且 $p$ 在 $q$ 之前，则下列 $p$ 与 $q$ 的关系中，不可能的是（ ）。
>
I. $q$ 是 $p$ 的双亲  
II. $q$ 是 $p$ 的右孩子  
III. $q$ 是 $p$ 的右兄弟  
IV. $q$ 是 $p$ 的双亲的双亲
>
A. 仅 I  
B. 仅 III  
C. 仅 II、III  
D. 仅 II、IV

> [!success] 解析
> 选B

> [!note] 总结
> 这题看错了
##### **知识关联**
- [[二叉树的#中序遍历（InOrder）]]


## 007



> [!question] 题干
> 某二叉树 $T$ 采用二叉链表存储结构，$T$ 的中序遍历序列为一个升序序列，要求采用某种方法对 $T$ 进行某种操作之后得到一棵新的二叉树 $T'$，要求 $T'$ 的中序遍历序列为一个降序序列，则下列关于该算法的叙述中，正确的是（ ）
>
A. 采用中序遍历的方法最合适  
B. 采用后序遍历的方法最合适  
C. $T'$ 中的根结点一定不是原 $T$ 中的根结点  
D. $T'$ 中的叶结点不一定是原 $T$ 中的叶结点

> [!success] 解析
> 只要交换 $T$ 中所有分支结点的左右子树，就能得到一棵中序遍历序列为降序序列的树，而这并不会改变根结点，叶结点也仅仅交换位置，仍是原 $T$ 中的叶结点，选项 C、D 错误。交换 $T$ 中所有分支结点的左右子树，要么先处理根结点，然后递归地处理左右子树，即先序遍历；要么先处理左右子树，然后处理根结点，即后序遍历；中序遍历是不适合的。选项 A 错误，选项 B 正确。

> [!note] 总结
> 
##### **知识关联**
- 




## 008



> [!question] 题干
>  在 BFS 算法中，若将辅助队列替换为栈，则遍历序列会发生什么变化？

> [!success] 解析
> 其行为将类似于DFS遍历

> [!note] 总结
> 1. **队列与 BFS 的绑定（先进先出）**： 广度优先搜索（BFS）类似于树的层序遍历，它必须借助一个**辅助队列**来实现。当你访问一个顶点时，将其所有未访问的邻接点排入队尾。由于队列“先进先出”，算法必须老老实实把“当前层”的邻接点全部出队访问完，才能开始访问“下一层”的顶点。
> 2. **栈与 DFS 的绑定（后进先出）**： 深度优先搜索（DFS）类似于树的先序遍历，遵循尽可能“深”地探索的策略，且**深度优先搜索需要用到栈**（无论是递归底层的隐式工作栈，还是非递归的显式栈）。
> 3. **替换后的化学反应**： 如果你把 BFS 代码里的队列硬生生换成栈：当你访问顶点 A，并把它的邻接点 B、C 压入栈后。下一步执行“出栈”时，弹出的不再是先发现的 B，而是最后压入的 C。紧接着，算法会立刻去探索 C 的邻接点并将它们压栈，导致 B 被越压越深。这使得算法**立刻抛弃了当前的层级，转而向更深处探索**，这正是标准的 DFS 行为。


> [!example]+ 举例
> 假设有一棵极简的图（树形结构）：起点 A，A 的孩子是 B 和 C；B 的孩子是 D。
>
> - **原版 BFS（使用队列）**：
>     1. A 入队。
>     2. A 出队并访问，将邻接点 B、C 入队。（队列：B, C）
>     3. B 出队并访问，将其邻接点 D 入队。（队列：C, D）
>     4. C 出队并访问。（队列：D）
>     5. D 出队并访问。
>     6. **访问序列**：`A -> B -> C -> D`（完美的按层遍历）。
> - **魔改后（将队列替换为栈）**：
>     1. A 入栈。
>     2. A 出栈并访问，将邻接点 B、C 入栈。（此时栈底是 B，栈顶是 C）。
>     3. **注意转折**：此时弹出的是栈顶 **C** 并访问！C 没有孩子，不入栈。（栈内剩：B）。
>     4. 弹出 **B** 并访问，将其邻接点 D 入栈。（栈内剩：D）。
>     5. 弹出 **D** 并访问。
>     6. **访问序列**：`A -> C -> B -> D`。
 	  **结论**：这个序列顺着 A 走到了 C，再回溯走 B 和 D。这完全就是 DFS 的纵向深搜逻辑，绝对不是 BFS（A B C D）的逆序（D C B A）。
##### **知识关联**
- [[深度优先搜索]]
- [[广度优先搜索]]
- [[栈]]
- [[队列]]





## 009



> [!question] 题干
> 若无向图 G 有 n 个顶点和 e 条边，其生成森林中包含的边数为：

> [!success] 解析
> 每个连通分量的生成树边数为$n_i-1$,求和得到$\sum(n_i-1)=n-m$,其中m表示连通分量数

> [!note] 总结
> 
##### **知识关联**
- [[图的基本概念]]



## 010



> [!question] 题干
> 设有 7 个顶点的无向图，若该图是有回路的，则其边数至少为：

> [!success] 解析
> 最简单的回路是三角形（3个顶点3条边），无论总顶点数多少，只要有3条边就可能构成环。

> [!note] 总结
> 
##### **知识关联**
- [[图的基本概念]]









<!-- COUNTER: 10 -->

