---
topic: Cache（高速缓冲存储器）
module: 存储系统
tags:
  - "#Cache"
  - "#存储层次"
  - "#AMAT"
exam_weight: 高
one_liner: 用“块/行+局部性”把主存访问摊薄成少量缺失代价，核心考命中/缺失/写策略/AMAT
updated: 2026-01-23
---

> [!summary] 🧠 概念卡｜Cache（存储系统）
> 
> - 题眼永远围绕：**地址分解**（tag/index/offset）→**命中判定**→**缺失处理**→**写策略**→**AMAT/性能**
>     
> - “会不会快”取决于：**命中率**、**缺失代价**（miss penalty）、**是否写回/写分配**
>     
> - 408常考输出：**映射方式对比**、**替换算法**、**缺失类型**（冷/容量/冲突）、**写策略组合**、**AMAT**
>     
> - 复习抓手：把一次访问拆成“命中快速路”和“未命中慢路径”，再把慢路径拆成“取块+替换+写回(可选)+填充”
>     
> - 参考：
>     

> [!note] 🎯 为什么需要（只写“问题与动机”，不写定义）
> 
> - CPU与主存速度差距大：每次都等主存会把**流水线/执行单元饿死**
>     
> - 程序访问呈局部性：把“经常用的少量数据/指令”放近处能显著减少平均等待
>     
> - 主存带宽有限：Cache用块传输把**多次邻近访问**合并成一次缺失代价
>     
> - 多级层次需求：L1/L2/L3分担“低延迟/大容量/共享”矛盾
>     

> [!info] 🔗 机制链条（背诵版｜结构清晰）
> 
> - 触发(发生一次读/写内存访问：取指或访数)
>     
> - → 输入(物理地址A；Cache参数：块大小B、组数S、路数E；写策略/替换策略)
>     
> - → 核心步骤〔地址分解→查index组选行→比较tag→命中则返回/更新；未命中则选牺牲行→必要时写回→从下一级取块填充→再完成本次访问〕
>     
> - → 输出〔命中：以Cache延迟返回数据；未命中：付缺失代价后返回数据；同时更新Cache状态(有效/脏/替换信息)〕
>     
> - → 副作用/代价〔需要比较器+Tag存储+替换状态位；一致性/写回复杂度；缺失会阻塞(或需非阻塞Cache)〕
>     
> - → 失败/异常分支〔缺失类型上升(冲突/容量)→命中率下降；写回遇到下级忙→延迟放大；多核下不一致→需一致性协议/写缓冲〕
>     

> [!tip] 🧭 流程/时序/控制（伪图示｜画关键分支与控制信号）
> 
> ```text
> CPU发起访问(A, R/W)
>   │
>   ├─ 地址分解：offset=log2(B), index=log2(S), tag=剩余
>   │
>   ├─ 读/写并行：读出该index组的E路(tag+valid+dirty+data片段)
>   │
>   ├─ tag比较
>   │    ├─ 命中(Hit)
>   │    │    ├─ Read：data=CacheLine[offset]
>   │    │    └─ Write：
>   │    │         ├─ 写直达(Write-through)：同时写下级(常配写缓冲)
>   │    │         └─ 写回(Write-back)：仅改Cache并置dirty=1
>   │    │
>   │    └─ 未命中(Miss)
>   │         ├─ 判缺失类型：冷(首次) / 冲突(组内挤) / 容量(整体不够)
>   │         ├─ 写策略分支(写未命中时)：
>   │         │    ├─ 写分配(Write-allocate)：先取块入Cache再写
>   │         │    └─ 不写分配(No-write-allocate)：直接写下级不入Cache
>   │         ├─ 选牺牲行(替换：LRU/近似LRU/FIFO/随机)
>   │         ├─ 若牺牲行为dirty且写回：先WriteBack到下一级
>   │         ├─ 从下一级取整块Fill到Cache(置valid=1, dirty按写策略)
>   │         └─ 重放本次访问(完成读/写)
> 
> 计算落点：
>   AMAT = HitTime + MissRate × MissPenalty
>   多级：AMAT = HT_L1 + MR_L1 × (HT_L2 + MR_L2 × (HT_L3 + ...))
> ```

> [!example] 🧮 计算模板（题型 → 公式 → 代入顺序 → 单位/量纲）
> 
> - 题型1：**地址划分/Cache参数反推**
>     
>     - 公式：块大小B=2^b；组数S=2^s；主存地址m位 ⇒ tag位=t=m−s−b
>         
>     - 代入顺序：先由“行大小/块大小”定b→由“组数/容量/路数”定s→最后算t
>         
>     - 单位：B用**字节**；容量用**B/KB**；位数用**bit**
>         
> - 题型2：**AMAT/平均访存时间**
>     
>     - 公式：AMAT=HT+MR×MP（HT/MP单位：ns或周期；MR无量纲）
>         
>     - 代入顺序：先统一单位→算MR→算MP（常给主存时间/下级命中时间）→最后带入
>         
>     - 取整：**周期数**通常向上取整；ns不取整除非题干说明
>         
> - 题型3：**缺失代价/带宽相关**
>     
>     - 公式：MP≈(下级访问启动延迟)+（块传输字节数/总线带宽）
>         
>     - 代入顺序：先算“块字节数”→算传输时间→加启动/排队开销
>         

> [!abstract] 🧾 最小对比表（只保留能得分的维度）
> 
> |维度|直接映射|全相联|组相联（E路）|
> |---|---|---|---|
> |冲突缺失|高|低|中（随E增大而降）|
> |硬件代价|低（1次比较）|高（多路比较）|中（E路比较）|
> |命中时间|最短|最长|介于两者|
> |典型考点|index/tag划分、冲突缺失|替换算法必须|“路数↑命中↑但HT↑”权衡|

> [!question] 🧩 真题命题信号词 → 直接定位
> 
> - “**主存地址x位/块大小/组相联E路**”→先做**地址分解**(tag/index/offset)
>     
> - “**缺失率/命中率/平均访存时间**”→直接套**AMAT**（注意多级乘法链）
>     
> - “**写回/直写、写分配/不写分配**”→按**写命中/写未命中**分4种组合讨论
>     
> - “**LRU/FIFO/随机**”→替换序列题：画组内E路状态随访问更新
>     
> - “**冷缺失/容量缺失/冲突缺失**”→结合映射方式与容量变化判断缺失类型
>     

> [!warning] ⚠ 易错点清单（带自检）
> 
> -  我是否把**组数S**和**行数(line数)**区分清楚（行数=组数×路数）？
>     
> -  我是否统一了**块大小单位**（字节/字）并处理了字长换算？
>     
> -  我是否在“写未命中”时明确分支：**写分配 vs 不写分配**（别只写写回/直写）？
>     
> -  我算AMAT时是否把**L2/L3命中时间**正确地乘上了上一级的缺失率？
>     
> -  我判断缺失类型时是否能解释：**直接映射更易冲突缺失**、容量不足导致容量缺失？
>     

> [!success] ✅ 可直接套用的答题骨架（选择/简答/计算通用）
> 
> - 先落点：本题考**地址分解/映射方式/写策略/替换/AMAT**中的哪一类
>     
> - 写“快慢路径”：**命中：比较tag→读/写→(直写/置脏)**；**未命中：判写分配→替换→(必要写回)→取块填充→重放**
>     
> - 说清权衡：路数↑→冲突缺失↓但比较开销↑、命中时间↑；写回省带宽但实现复杂+一致性难
>     
> - 计算题按顺序：参数→位数划分→命中/缺失→AMAT；最后检查单位/取整规则
>     

> [!quote] 🔗 知识网络（双链串题）
> 
> - [[局部性原理]] → [[存储层次结构]] → [[Cache映射方式]] → [[替换算法LRU_FIFO_随机]]
>     
> - [[写策略（写回_直写）]] ↔ [[写分配策略]] ↔ [[写缓冲与一致性问题]]
>     
> - [[AMAT平均访存时间]] ↔ [[多级Cache（L1_L2_L3）]] ↔ [[流水线性能与访存瓶颈]]
>