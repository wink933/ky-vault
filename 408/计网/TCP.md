---

topic: "TCP"  
module: "传输层"  
input_type: "概念"  
exam_weight: "高"  
one_liner: "把“不可靠的IP尽力而为”包装成“面向连接、可靠有序、可控速率”的端到端传输通道。"  
why_needed:

- "应用需要“按序不丢不重”的字节流语义，但IP只保证尽力而为：可能丢包/乱序/重复"
    
- "发送端与接收端速率不匹配会淹没接收缓冲：需要端到端流量控制避免接收端被打爆"
    
- "网络负载上升会引发排队与丢包放大：需要端到端拥塞控制在不可靠网络上稳定收敛"
    

keywords:

- "三次握手/四次挥手/半连接与全连接"
    
- "序号seq/确认号ack/累计确认/重复ACK"
    
- "重传：RTO超时/快重传(3重复ACK)/SACK(若支持)"
    
- "滑动窗口：发送窗口/接收窗口rwnd/通告窗口"
    
- "拥塞控制：cwnd/ssthresh/慢启动/拥塞避免/快恢复"
    
- "RTT估计/超时重传计时器/指数回退"
    
- "MSS/MTU/延迟ACK/Nagle(考点常联动)"
    

signals:

- "题干出现：可靠传输/按序/丢包重传/滑动窗口/ACK/seq/rwnd/cwnd/ssthresh"
    
- "问：三次握手为什么不是两次/四次挥手为什么不是三次/哪些状态会进入TIME_WAIT"
    
- "给出窗口大小/序号范围/丢包位置，问：发送端还能发多少/会重传哪些段/ACK如何变化"
    
- "问：RTO超时 vs 3重复ACK触发行为差异；Tahoe/Reno/NewReno区别"
    

pitfalls:

- "把“流量控制(rwnd)”与“拥塞控制(cwnd)”混为一谈，忘了最终发送窗口=min(rwnd,cwnd)"
    
- "误以为ACK是逐段确认：TCP常用累计确认；重复ACK不等于新数据确认"
    
- "把三次握手目的说成“协商加密/交换路由”：核心是同步初始序号+确认双向可达+避免旧连接干扰"
    
- "误判TIME_WAIT作用：不是“浪费”，而是防旧报文混入+保证最后ACK可重传"
    
- "混淆重传触发：RTO超时会更激进降速；3重复ACK走快重传/快恢复(实现随版本不同)"
    

comparisons:

- "TCP_vs_UDP"
    
- "Tahoe_vs_Reno_vs_NewReno"
    
- "累计确认_vs_SACK"
    
- "超时重传_vs_快重传"
    

links:

- "数据链路层可靠传输：GBN/SR与滑动窗口的类比"
    
- "IP分片/PMTUD与MSS选择：为什么MSS不是越大越好"
    
- "应用层HTTP/流式媒体：为什么有时宁用UDP+应用层可靠"
    
- "Socket：端口复用/四元组(源IP源端口目的IP目的端口)标识连接"
    

source: "2026计算机网络.pdf 第5章5.3 TCP "  
pattern_name: "连接管理→可靠交付(序号+ACK+重传)→流控(rwnd)→拥控(cwnd)→有序释放"  
last_update: "2026-01-22"  
tags:

- "TCP"
    
- "传输层"
    
- "可靠传输"
    
- "滑动窗口"
    
- "拥塞控制"
    

---

## 1) 速记总结

- 把“可能丢乱重”的网络，变成“按序不丢不重”的**字节流**：序号+累计ACK+重传
    
- 把“接收端扛不住”变成“发多少由接收端说了算”：**rwnd**（流量控制）
    
- 把“网络扛不住”变成“发多少由网络状态说了算”：**cwnd/ssthresh**（拥塞控制）
    
- 发送端真正能飞出去的量：**发送窗口 = min(rwnd, cwnd)**
    

## 2) 机制链条（可背版本）

有可靠/按序/控速需求的进程通信 → 输入(字节流、MSS、连接四元组、RTT/窗口信息) → 核心步骤(1三次握手同步初始序号与双向可达 2分段编号发送并维护发送窗口 3接收端累计ACK+乱序缓存/丢弃策略 4丢包则RTO超时重传或3重复ACK快重传 5用rwnd做流控、用cwnd做拥控并取min限制发送 6四次挥手与TIME_WAIT完成有序释放) → 输出(对应用呈现可靠有序字节流/连接释放) → 副作用/代价(首部与状态开销、握手/挥手时延、队头阻塞、拥控导致吞吐波动) → 失败/异常分支(SYN洪泛/半连接耗尽、连接复位RST、超时重传放大、窗口为0探测与恢复)

## 3) 状态机/流程（伪图示）

```
三次握手(建立)
CLOSED
  |  connect()
  v
SYN_SENT --(SYN)--> ...
  |<--(SYN+ACK)--
  v
ESTABLISHED <--(ACK)--  LISTEN/SYN_RCVD侧完成建立

四次挥手(释放，主动关闭方)
ESTABLISHED
  | close()
  v
FIN_WAIT_1 --(FIN)-->
  |<--(ACK)--
  v
FIN_WAIT_2
  |<--(FIN)--
  v
TIME_WAIT --(ACK)--> (等待2MSL)
  v
CLOSED

被动关闭方(概念链)
ESTABLISHED -> CLOSE_WAIT(收FIN并回ACK) -> LAST_ACK(发FIN) -> CLOSED(收ACK)

数据传输(窗口推进)
send_base ...... nextseqnum
[已确认][已发送未确认][可发送][不可发送]
          ^累计ACK推进send_base，窗口整体右移
```

## 4) 代价与边界

- **队头阻塞**：按序交付会让“前面缺口”卡住后续数据，丢一个段可能拖慢整条流
    
- **握手/挥手时延**：短连接对RTT敏感；优化往往在复用连接/减少往返上做文章
    
- **流控 vs 拥控边界**：rwnd反映接收端能力；cwnd反映网络拥塞；两者同时约束
    
- **拥塞控制必考细节**：
    
    - 变量：cwnd、ssthresh
        
    - 阶段：慢启动(cwnd指数涨)→到阈值后拥塞避免(线性涨)
        
    - 触发差异：RTO超时 vs 3重复ACK
        
        - RTO超时：认为更严重拥塞，cwnd大幅回退，ssthresh下调，重新慢启动
            
        - 3重复ACK：走快重传/快恢复，通常不回到1个MSS那么“狠”
            
    - 一句话对照：Tahoe丢包后回慢启动；Reno在3重复ACK走快恢复；NewReno在多丢包/部分ACK场景恢复更稳更不易退化
        

## 5) 对比与替代（最小对比表）

|维度|方案A：TCP|方案B：UDP(配合应用层机制)|
|---|---|---|
|目标|端到端可靠有序+流控+拥控的字节流|低开销低时延的报文交付，可靠性/顺序由应用自定|
|代价|状态与首部开销、握手挥手时延、队头阻塞、拥控波动|需要应用自己处理重传/排序/拥控，写起来更复杂且更易踩坑|
|典型考法|握手挥手状态、ACK/seq/窗口、RTO vs 3重复ACK、cwnd/ssthresh演化|校验和/端口复用、面向报文、何时选UDP、应用层可靠设计|

## 6) 真题命题模板

- 模板A：握手挥手推演  
    给：谁先close/是否同时关闭/是否丢包 → 问：状态序列、TIME_WAIT在哪一方、为什么要2MSL
    
- 模板B：序号与累计ACK  
    给：发送段序号/丢失位置/乱序到达 → 问：ACK号如何变化、哪些段被重传、窗口如何推进
    
- 模板C：窗口综合(min(rwnd,cwnd))  
    给：rwnd、cwnd、已发送未确认字节数 → 问：还能发多少、何时阻塞、0窗口如何恢复
    
- 模板D：拥塞控制曲线  
    给：初始cwnd/阈值/丢包触发类型(RTO或3dupACK) → 问：cwnd/ssthresh变化、阶段切换点、版本对比
    

## 7) 易错点清单（带自检）

-  我是否把发送窗口写成了rwnd或cwnd之一而不是min(rwnd,cwnd)
    
-  我是否把累计确认当成逐段确认(ACK=k表示期望下一个字节/段的序号)
    
-  我是否能明确区分：RTO超时 vs 3重复ACK对应的cwnd回退方式
    
-  我是否说清TIME_WAIT的两件事：防旧报文混入+保证最后ACK可重传
    
-  我是否把挥手次数想当然：半关闭导致FIN与ACK/数据方向分离，常见为四次
    

## 8) 迁移题型模型（可直接套用）

- “判控制维度”模型：题目问接收端承载→看rwnd；问网络拥塞→看cwnd；真正能发→取min
    
- “丢包定位”模型：ACK不前进+重复ACK增多→怀疑中间缺口；RTO出现→更严重或测不到ACK
    
- “状态归因”模型：建立靠SYN序列；释放靠FIN半关闭；异常复位看RST；等待收敛看TIME_WAIT
    

## 9) 知识网络（用于串题）

- 与链路层：GBN/SR滑动窗口思想迁移到TCP(但TCP是字节流+累计ACK为主)
    
- 与网络层：MTU/MSS选择影响分段与丢包概率，串PMTUD与分片风险
    
- 与应用层：HTTP短连接/长连接、RPC超时重试与TCP重传叠加导致“重试风暴”
    
- 与安全：SYN洪泛导致半连接耗尽，串防护(SYN cookie等概念点)