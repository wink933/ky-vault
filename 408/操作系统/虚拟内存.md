---

topic: "虚拟内存"  
module: "虚拟内存"  
tags:

- "#虚拟内存"
    
- "#请求分页"
    
- "#缺页中断"
    
- "#页面置换"  
exam_weight: "高"  
one_liner: "用“按需装入+缺页异常+置换”把大地址空间映射到小内存，靠局部性换性能与容量"  
updated: "2026-01-23"
    

---

> [!summary] 🧠 概念卡｜虚拟内存（虚拟内存）
> 
> - 把“程序想要的地址空间”与“实际物理内存”解耦：看起来很大，实际按需用
>     
> - 核心抓手：局部性假设 + 请求分页（或请求分段）+ 缺页异常处理
>     
> - 得分点通常落在：缺页中断流程、页表/有效位/脏位、置换算法、抖动与工作集、TLB协同
>     
> - 一句话落地：**命中就快跑，未命中就缺页→找页框→必要时置换→更新映射→重启指令**
>     

> [!note] 🎯 为什么需要（只写“问题与动机”，不写定义）
> 
> - 程序/进程地址空间远大于物理内存：必须“看起来能装下”
>     
> - 多道程序并发：希望提升内存利用率与系统吞吐（别让内存被“没用到的部分”占满）
>     
> - 进程隔离与保护：不同进程互不干扰，访问越界可被硬件/OS拦截
>     
> - 简化装入与运行：不用整段/整程序一次性装入，减少启动等待与I/O压力
>     

> [!info] 🔗 机制链条（背诵版｜结构清晰）
> 
> - 触发(访问某虚拟页：取指/读/写)
>     
> - → 输入(虚拟地址VA；TLB/页表项PTE〔有效位/访问位/脏位/权限〕；内存空闲页框信息)
>     
> - → 核心步骤〔TLB查找→未命中查页表→若PTE有效则建立TLB并继续；若PTE无效则触发缺页异常→OS选页框(空闲/置换)→必要时回写脏页→从外存调入目标页→更新PTE/TLB→重启被中断指令〕
>     
> - → 输出〔形成VA→PA映射；目标页驻留；指令继续执行〕
>     
> - → 副作用/代价〔缺页开销大(磁盘I/O)；页表/管理结构占内存；TLB一致性维护；可能产生抖动〕
>     
> - → 失败/异常分支〔非法访问/权限不够→异常终止；外存读失败→I/O错误；频繁缺页→抖动→需调节驻留集/降低并发〕
>     

> [!tip] 🧭 流程/状态机（伪图示｜画关键分支）
> 
> ```text
> 访存(VA)
>   |
>   v
> 查TLB
>   |-- 命中 --> 得到PA --> 访问内存 --> 继续执行
>   |
>   `-- 未命中 --> 查页表(PTE)
>                 |-- PTE有效(在内存) --> 填TLB/更新访问位 --> 得到PA --> 继续执行
>                 |
>                 `-- PTE无效(不在内存) --> 缺页异常(trap到内核)
>                                      |
>                                      v
>                                选页框(空闲? / 置换?)
>                                      |-- 有空闲 --> 直接装入
>                                      `-- 无空闲 --> 选牺牲页
>                                                   |-- 脏? 是 --> 回写外存
>                                                   `-- 脏? 否 --> 免回写
>                                      |
>                                      v
>                                读入目标页(外存->页框)
>                                      |
>                                      v
>                                更新PTE/TLB/权限位
>                                      |
>                                      v
>                                重启原指令(同一条再执行)
> ```

> [!abstract] 🧾 最小对比表（只保留能得分的维度）
> 
> |维度|基本分页（无请求）|请求分页（虚拟内存常考）|
> |---|---|---|
> |装入策略|全部装入|按需装入（缺页再调入）|
> |关键硬件/位|页表/地址变换|页表+有效位(在/不在)+访问位+脏位+TLB|
> |异常机制|一般无缺页|缺页异常 + 中断返回重启指令|
> |性能瓶颈|内存访问次数|缺页I/O主导；TLB命中率与缺页率决定体验|
> |风险点|内存占用高|置换不当→抖动；驻留集过小→频繁缺页|

> [!question] 🧩 真题命题信号词 → 直接定位
> 
> - “有效位/存在位/访问位/脏位/权限位” → PTE字段含义 + 缺页/回写分支
>     
> - “TLB命中/缺页率/访存次数” → 地址翻译开销计算（先TLB再页表）
>     
> - “请求分页/按需装入/缺页中断(异常)” → 写完整处理流程（含重启指令）
>     
> - “FIFO/LRU/Clock(二次机会)/OPT” → 置换算法特点与缺陷（Belady异常等）
>     
> - “抖动/工作集/驻留集/局部性” → 为什么抖动 + 怎么控缺页（调驻留集/降并发）
>     

> [!warning] ⚠ 易错点清单（带自检）
> 
> -  我是否把“缺页中断”说成外设中断？（自检：它是**异常/陷入**，由访存触发）
>     
> -  我是否忘了“重启原指令”？（自检：缺页处理后通常回到同一条指令重新执行）
>     
> -  我是否把“TLB未命中”当成“缺页”？（自检：TLB未命中≠页不在内存，仍可能页表命中有效）
>     
> -  我是否漏写“脏页才回写”？（自检：置换时先看脏位/修改位，脏才写回）
>     
> -  我是否把“LRU一定可实现”写死？（自检：严格LRU硬件代价高，常用近似如Clock）
>     

> [!success] ✅ 可直接套用的答题骨架（选择/简答通用）
> 
> - 先写动机（2句）：地址空间>内存 + 提升利用率/并发 + 隔离保护
>     
> - 再写三件套（必得分）：**局部性** + **请求分页(按需装入)** + **缺页异常处理**
>     
> - 画流程（按分支写）：TLB命中/未命中；PTE有效/无效；置换时脏/不脏
>     
> - 点名数据结构（点到即得分）：页表PTE字段(有效/访问/脏/权限)、TLB、空闲页框表/置换队列
>     
> - 收尾写代价与边界：缺页I/O开销大；缺页率高→抖动；用工作集/驻留集/置换算法/降低并发缓解
>     

> [!quote] 🔗 知识网络（双链串题）
> 
> - [[地址翻译]] ↔ [[TLB]] ↔ [[页表项PTE]]
>     
> - [[缺页中断处理]] ↔ [[页面置换算法]] ↔ [[FIFO与Belady异常]]
>     
> - [[LRU]] ↔ [[Clock算法]] ↔ [[访问位与近似LRU]]
>     
> - [[抖动]] ↔ [[工作集模型]] ↔ [[驻留集与页框分配]]
>     
> - [[段页式管理]] ↔ [[请求分段]] ↔ [[内存保护与共享]]
>