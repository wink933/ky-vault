---

topic: "进程"  
module: "进程与线程"  
tags:

- "#进程"
    
- "#进程与线程"
    
- "#操作系统"  
exam_weight: "高"  
one_liner: "以PCB为核心的资源分配与调度基本单位：用“状态+队列+切换”把CPU与资源管理起来"  
updated: "2026-01-23"
    

---

> [!summary] 🧠 概念卡｜进程（进程与线程）
> 
> - 抓主干：**PCB + 进程映像 + 状态/队列** → 才能调度、切换、控制、统计
>     
> - 记关键：**创建/撤销/阻塞/唤醒/切换**五类控制点，题目常围绕“谁改状态、改哪里”
>     
> - 识别考法：给你现象（并发/共享/阻塞/切换开销）→ 追到“状态图+队列+PCB字段”
>     
> - 常设默认：**单核、可抢占、经典五状态模型**（就绪/运行/阻塞/创建/终止）
>     
> - 口径参考：
>     


> [!note] 🎯 为什么需要（只写“问题与动机”，不写定义）
> 
> - 只有“程序”不够：要在**并发**下让多个任务轮流用CPU，还要能**暂停/恢复**
>     
> - 需要“可管理对象”：系统要能对每个任务做**资源分配、权限约束、统计与回收**
>     
> - 要把“正在运行的现场”保存下来：否则一切切换都会把计算结果弄丢
>     
> - 要把“等待资源/事件”的任务先放一边：避免CPU空转、提高吞吐
>     
> - 要为同步互斥/通信提供载体：共享资源、消息传递都要“挂靠在实体”上
>     


> [!info] 🔗 机制链条（背诵版｜结构清晰）
> 
> - 触发(并发执行需求/系统调用fork&exec/作业进入/事件到达/时间片到)
>     
> - → 输入(进程控制信息：程序段+数据段+打开文件+寄存器现场+优先级/时间片+队列指针)
>     
> - → 核心步骤〔建立/维护PCB；状态迁移；挂入/摘出就绪/阻塞队列；上下文切换保存/恢复现场；资源分配与回收〕
>     
> - → 输出〔“可被调度的实体”+一致的运行现场；系统可对其执行创建/撤销/阻塞/唤醒/切换〕
>     
> - → 副作用/代价〔上下文切换开销；内存/PCB管理开销；并发带来同步互斥复杂度；缓存/TLB局部性被打断〕
>     
> - → 失败/异常分支〔资源不足→创建失败/阻塞等待；非法访问/异常→进程终止；死锁/饥饿→长期不前进〕
>     


> [!tip] 🧭 流程/状态机（伪图示｜画关键分支）
> 
> ```text
> [创建]
>   |  分配PCB/资源，装入/建立映像
>   v
> [就绪] --(调度/被选中)--> [运行]
>   ^                         |
>   |                         | (时间片用完/更高优先级到来/可抢占)
>   |                         v
>   +---------(被抢占)------ [就绪]
>                             |
>                             | (等待I/O/事件/资源)  ← 分支1：主动放弃CPU
>                             v
>                          [阻塞]
>                             |
>                             | (I/O完成/事件发生/资源到位) ← 分支2：被动唤醒
>                             v
>                          [就绪]
> 
> [运行] --(正常退出/被kill/异常)--> [终止] --(回收资源/删除PCB)--> 结束
> ```
> 
> - 画图必点：**就绪队列/阻塞队列**（“在哪里等”是得分点）
>     
> - 分支抓手：**可抢占**决定“运行→就绪”的触发条件
>     
> - 恢复执行：切换后继续从“被中断/被抢占的下一条指令”附近推进（重启点）
>     


> [!abstract] 🧾 最小对比表（只保留能得分的维度）
> 
> |对比对象|调度单位|资源拥有|切换开销|典型考点|
> |---|---|---|---|---|
> |程序 vs 进程|程序不可调度|程序=静态；进程=动态占用资源|进程可切换|“静态/动态”“并发/共享”|
> |进程 vs 线程|线程常为CPU调度基本单位|进程有独立地址空间；线程共享进程资源|线程切换通常更轻|“为什么线程更轻”“共享带来同步”|
> |单进程内多线程 vs 多进程|线程级并发|线程共享更强|多进程更重但隔离更强|“隔离/容错/安全”取舍|


> [!question] 🧩 真题命题信号词 → 直接定位
> 
> - “**PCB里有什么/有哪些指针字段**” → 状态队列链接、现场、资源表、优先级/时间片等
>     
> - “**就绪/阻塞/运行如何转换**” → 画五状态图 + 说明触发事件（I/O、时间片、唤醒）
>     
> - “**进程切换做了什么**” → 保存/恢复上下文 + 切换地址空间 + 队列操作
>     
> - “**并发 vs 并行**” → 单核并发=交替推进；并行=多核同刻推进（别混）
>     
> - “**父子进程/创建开销/exec**” → 创建分配PCB与资源；装入程序与映像更新
>     


> [!warning] ⚠ 易错点清单（带自检）
> 
> -  我是否把“程序(静态)”当成“进程(动态可调度)”在答？
>     
> -  我是否把“就绪”说成“在CPU上跑”？（就绪=可运行但**没拿到CPU**）
>     
> -  我是否漏写“阻塞队列/就绪队列”而只写状态名？（队列=管理抓手）
>     
> -  我是否把“进程切换”和“线程切换”开销/原因混为一谈？
>     
> -  我是否把“被抢占(运行→就绪)”和“阻塞(运行→阻塞)”触发条件写反？
>     
> -  我是否在“唤醒”时直接说“阻塞→运行”？（通常是阻塞→就绪→被调度→运行）
>     


> [!success] ✅ 可直接套用的答题骨架（选择/简答通用）
> 
> - 先给框架：**PCB为核心 + 状态/队列 + 控制原语**（一句话立住）
>     
> - 再写机制链：创建/撤销/阻塞/唤醒/切换各自“触发条件→改状态→进队/出队→是否保存现场”
>     
> - 画状态图：至少标出**运行↔就绪**（可抢占）与**运行→阻塞→就绪**（I/O/事件）
>     
> - 点代价：上下文切换开销、并发同步互斥成本、共享导致一致性问题
>     
> - 落到题干：把题目给的事件（I/O完成/时间片到/中断/唤醒）映射到“哪条边”
>     


> [!quote] 🔗 知识网络（双链串题）
> 
> - [[PCB与进程映像]] ↔ [[进程状态与转换]] ↔ [[进程控制-创建撤销阻塞唤醒]]
>     
> - [[CPU调度与进程切换]] ↔ [[抢占式调度]] ↔ [[上下文切换开销]]
>     
> - [[同步与互斥]] ↔ [[信号量PV]] ↔ [[管程]] ↔ [[经典同步问题]]
>     
> - [[进程通信IPC]] ↔ [[共享内存]] ↔ [[消息传递]] ↔ [[管道与套接字]]
>     
> - [[死锁]] ↔ [[资源分配图]] ↔ [[银行家算法]]
>