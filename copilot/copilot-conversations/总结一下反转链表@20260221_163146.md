---
epoch: 1771662706789
modelKey: "qwen2.5-7b-instruct|lm-studio"
topic: "反转链表方法总结"



tags:
  - copilot-conversation
---

**user**: 总结一下反转链表
[Context: Notes: 408/数据结构/Chapter 2 ：线性表/反转链表.md]
[Timestamp: 2026/02/21 16:31:46]

**ai**: 以下是关于“反转链表”的系统性总结，涵盖核心概念、实现方法、注意事项及适用场景，适合复习或快速回顾：

---

## 🎯 反转链表要做什么？

将原链表的节点顺序完全颠倒：

```
原链表：1 -> 2 -> 3 -> null
反转后：3 -> 2 -> 1 -> null
```

**核心操作**：每个节点的 `next` 指针指向其前驱（即原来前面的节点）。

---

## 🧩 实现方法

### ✅ 方法一：迭代法（三指针）

#### 💡 思路：
使用三个指针：

- `prev`：已反转部分的头结点（初始为 `NULL`）
- `cur`：当前要处理的节点（初始为原链表头）
- `nxt`：暂存 `cur->next`，防止断链

#### 🔄 步骤：
1. 保存后路：`nxt = cur->next`
2. 反转指向：`cur->next = prev`
3. 前进整体：`prev = cur; cur = nxt`

循环结束时，`prev` 即为新链表头。

#### ⏱️ 复杂度：
- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$

#### 💬 优点：
- 常数空间、高效稳定。
- 易于理解与调试。

---

### ✅ 方法二：递归法

#### 💡 思路：
先递归反转后半部分，再将当前节点接到新链表末尾：

- `reverse(head->next)` 返回已反转的后半段的新头
- 将原 `head` 插入到新链表头部（通过修改指针）
- 最终返回新头

#### ⏱️ 复杂度：
- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$（递归栈深度）

#### 💬 优点：
- 代码简洁，逻辑清晰。
- 适合理解“分治”思想。

#### ❗ 注意点：
- 必须设置 `head->next = NULL` 避免环
- 边界条件需处理：空链表或单节点

---

### ✅ 方法三：头插法（本质与迭代法相同）

从原链表依次取节点，**插入到新链表头部**：

```c
Node* reverse(Node* head){
    Node* newHead = NULL;
    while(head){
        Node* nxt = head->next;
        head->next = newHead;
        newHead = head;
        head = nxt;
    }
    return newHead;
}
```

#### 💬 说明：
- 和“三指针迭代法”逻辑一致，只是操作顺序不同。
- 更直观地体现“头插”的过程。

---

## ⚠️ 最容易错的点（必记！）

1. **未保存 `cur->next`** → 反转后断链
2. **忘记新头是 `prev` 或 `newHead`** → 返回错误结果
3. **递归法未设置 `head->next = NULL`** → 形成环
4. **未处理空链表或单节点情况** → 程序崩溃

---

## 📊 方法对比（考研重点）

| 方法       | 时间复杂度 | 空间复杂度 | 代码难度 | 是否易出错 | 推荐场景         |
|------------|-------------|--------------|-----------|---------------|------------------|
| 迭代法     | $O(n)$      | $O(1)$       | 中等       | 较少          | 考研高频、工程实用 |
| 递归法     | $O(n)$      | $O(n)$       | 简洁但易错 | 高            | 理解原理用        |
| 头插法     | $O(n)$      | $O(1)$       | 中等       | 较少          | 思维训练、辅助理解 |

---

## 📌 考研复习建议

- **必掌握**：迭代三指针法（最稳定）
- **可选掌握**：递归法（体现分治思想，但注意边界）
- **重点记忆**：新头是谁？如何避免断链和环？
- **真题模拟**：常考“反转链表+判断空/单节点”、“递归栈溢出风险”

---

✅ 总结一句话：

> 反转链表的本质是改变每个节点的 `next` 指向，核心在于保存后路、逐步反转、正确返回新头。

如需练习题或代码模板，可参考 [[反转链表]] 中的示例。
[Timestamp: 2026/02/21 16:33:00]