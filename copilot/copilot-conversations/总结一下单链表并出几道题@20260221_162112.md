---
epoch: 1771662072826
modelKey: "qwen2.5-7b-instruct|lm-studio"
topic: "单链表总结与练习题"



tags:
  - copilot-conversation
---

**user**: 总结一下单链表并出几道题
[Context: Notes: 408/数据结构/Chapter 2 ：线性表/单链表.md]
[Timestamp: 2026/02/21 16:21:12]

**ai**: 以下是关于**单链表**的系统性总结，并附带几道典型题目（含解析），适合用于复习或自测。

---

## ✅ 一、单链表核心概念总结

### 1. 定义与结构
- 单链表是线性表的一种**链式存储结构**，通过指针连接数据元素。
- 每个结点包含：
  - **数据域（data）**：存放实际数据；
  - **指针域（next）**：指向下一个结点。

> 📌 特点：不要求连续内存空间，插入/删除效率高，但不支持随机访问。

---

### 2. 头指针与头结点
| 名称       | 含义                     | 存在形式         |
|------------|--------------------------|------------------|
| **头指针** | 指向链表第一个结点（或头结点） | 带/不带头结点均可 |
| **头结点** | 辅助结点，无实际数据       | 仅在“带头结点”时存在 |

> ✅ 头结点优点：
- 插入、删除操作统一；
- 空表与非空表处理一致（无需特殊判断）。

---

### 3. 基本操作

| 操作         | 时间复杂度     | 关键说明 |
|--------------|----------------|----------|
| 初始化       | O(1)           | 创建头结点或置NULL |
| 求表长       | O(n)           | 遍历所有数据结点 |
| 插入（按位） | O(n)           | 须找前驱，若已知则O(1) |
| 删除（按位） | O(n)           | 同理，需找前驱 |
| 查找（按位/值） | O(n)         | 最坏情况遍历至尾部 |
| 头插法建表   | O(n)           | 元素顺序**逆序**存储 |
| 尾插法建表   | O(n)           | 元素顺序**正序**存储 |

---

## 📚 二、典型题目（含解析）

---

### 🔹 单选题

#### Q1：下列关于单链表
<errorChunk>Model reloaded.</errorChunk>
[Timestamp: 2026/02/21 16:22:01]

**user**: 总结一下双链表并出几道题
[Context: Notes: 408/数据结构/Chapter 2 ：线性表/单链表.md]
[Timestamp: 2026/02/21 16:22:19]

**ai**: 以下是关于**双链表**的系统性总结，并附带几道典型题目（含解析），适合用于复习或自测。

---

## ✅ 一、双链表核心概念总结

### 1. 定义与结构
- 双链表是线性表的一种**链式存储结构**，每个结点包含：
  - **数据域（data）**：存放实际数据；
  - **前驱指针（prior）**：指向其前一个结点；
  - **后继指针（next）**：指向其后一个结点。

> 📌 特点：
- 支持双向遍历（从前向后、从后向前）；
- 插入/删除操作效率高，但需维护两个指针；
- 存储空间开销比单链表大（每个结点多一个指针域）。

---

### 2. 头结点与头指针
- 双链表通常也**带头结点**，便于统一操作。
- **头指针指向头结点**；
- **尾指针可选**：用于快速访问表尾（优化插入/删除效率）。

> ✅ 优点：
- 插入、删除时无需遍历整个链表（若已知前驱或后继）；
- 可双向查找，灵活性高。

---

### 3. 基本操作

| 操作         | 时间复杂度     | 关键说明 |
|--------------|----------------|----------|
| 初始化       | O(1)           | 创建头结点并初始化前后指针 |
| 插入（按位） | O(n)           | 需找前驱，若已知则O(1) |
| 删除（按位） | O(n)           | 同理，需找前驱或后继 |
| 查找（按值/位） | O(n)         | 最坏情况遍历至尾部 |
| 头插法建表   | O(n)           | 元素顺序**逆序**存储 |
| 尾插法建表   | O(n)           | 元素顺序**正序**存储 |

> ⚠️ 注意：双链表的插入/删除操作比单链表更复杂，需同时修改前驱和后继指针。

---

## 📚 二、典型题目（含解析）

---

### 🔹 单选题

#### Q1：下列关于双链表的说法中，错误的是：
A. 双链表中的每个结点都有两个指针域  
B. 双链表支持双向遍历  
C. 插入操作的时间复杂度为O(1)（若已知前驱）  
D. 删除操作必须从头开始遍历才能找到目标结点  

✅ **答案：D**  
> 解析：删除操作如果已知前驱或后继，可直接修改指针，无需遍历。D选项错误。

---

#### Q2：在双链表中插入一个新结点p到结点q的后面，正确的操作是：
A. q.next = p; p.prior = q  
B. q.next = p; p.next = q.next; p.prior = q  
C. p.next = q.next; p.prior = q; q.next.prior = p  
D. p.next = q.next; q.next = p; p.prior = q  

✅ **答案：D**  
> 解析：插入后，p的next指向q原来的next；q的next指向p；p的prior指向q。选项D正确。

---

### 🔹 填空题

#### Q1：双链表中每个结点包含______个指针域。
✅ **答案：2**

#### Q2：在带头结点的双链表中，若要删除尾结点，则需要先找到______。
✅ **答案：尾结点的前驱结点（或尾指针）**

---

### 🔹 简答题

#### Q1：简述双链表与单链表的主要区别。

✅ **参考答案**：
- 单链表仅有一个后继指针，只能向前遍历；
- 双链表有两个指针域（前驱和后继），支持双向遍历；
- 插入/删除操作更灵活，但空间开销更大；
- 双链表在查找、插入、删除时可利用前后指针优化效率。

---

#### Q2：如何实现双链表的“头插法”建表？写出伪代码或关键步骤。

✅ **参考答案**：
1. 创建一个新结点p，赋值数据；
2. 将p的next指向当前头结点（原第一个有效结点）；
3. 将p的prior设为NULL（因为是头插法，无前驱）；
4. 更新头结点的prior指针指向p；
5. 头结点的next指向p。

> 伪代码示意：
```c
Node* p = new Node(data);
p->next = head->next;
p->prior = NULL;
head->next->prior = p;
head->next = p;
```

---

## 📌 总结建议（适合考研复习）

- **重点掌握**：双链表的结构、插入/删除操作逻辑；
- **对比记忆**：单链表 vs 双链表 —— 指针数量、遍历方向、空间开销；
- **常考题型**：指针修改顺序（如头插法）、时间复杂
[Timestamp: 2026/02/21 16:23:17]