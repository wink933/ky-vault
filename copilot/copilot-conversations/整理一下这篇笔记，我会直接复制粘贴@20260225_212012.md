---
epoch: 1772025612750
modelKey: "qwen2.5-7b-instruct|lm-studio"
topic: "整理笔记请求"



tags:
  - copilot-conversation
---

**user**: 整理一下这篇笔记，我会直接复制粘贴
[Context: Notes: 408/数据结构/Chapter 5 ：树与二叉树/并查集.md]
[Timestamp: 2026/02/25 21:20:12]

**ai**: 当然可以！以下是整理后的并查集笔记：

### 并查集

#### 概念
1. **基本操作**：
   - `Initial(S)`：将集合 S 中的每个元素都初始化为一个独立的单元素子集合。
   - `Union(S, Root1, Root2)`：将集合 S 中的子集合 Root2 并入子集合 Root1。要求 Root1 和 Root2 属于不同的子集合，否则不执行合并操作。
   - `Find(S, x)`：在集合 S 中查找单元素 x 所属的子集合，并返回该子集合的根结点。

#### 存储结构
- 并查集通常采用树的双亲表示法作为其存储结构：
  - 每个子集合用一棵树来表示，所有子集合共同构成一个森林。
  - 在数组中，数组下标代表集合中的元素编号，每个元素所存的值为其双亲结点的下标；对于根结点，其双亲域设为负数——通常取该子集合元素数量的相反数。

#### 示例
- 假设全集 $S = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\}$，初始化时每个元素自成一个单元素子集合，对应数组中每个位置的值均为 -1。

#### 并查集的基本实现
- **结构定义**：
  ```text
  #define SIZE 100
  int UFSets[SIZE];        // 集合元素数组（双亲指针数组）
  ```

- **初始化操作**：
  ```text
  void Initial(int S[]){
      for(int i=0; i<SIZE; i++)
          S[i] = -1;
  }
  ```

- **Find 操作**：
  ```text
  int Find(int S[], int x){
      while(S[x] >= 0)
          x = S[x];
      return x;
  }
  ```

- **Union 操作**：
  ```text
  void Union(int S[], int Root1, int Root2){
      if(Root1 == Root2) return;
      S[Root2] = Root1;
  }
  ```

#### 并查集的优化
- **改进的 Union 操作**：
  ```text
  void Union(int S[], int Root1, int Root2){
      if(Root1 == Root2) return;
      if(S[Root2] > S[Root1]){
          S[Root1] += S[Root2];
          S[Root2] = Root1;
      }
      else{
          S[Root2] += S[Root1];
          S[Root1] = Root2;
      }
  }
  ```

- **改进的 Find 操作**：
  ```text
  int Find(int S[], int x){
      int root = x;
      while(S[root] >= 0)
          root = S[root];
      while(x != root){
          int t = S[x];
          S[x] = root;
          x = t;
      }
      return root;
  }
  ```

#### 性能优化
- **路径压缩**：在找到根结点后，将从 x 到根路径上的所有中间结点直接连接到根结点下。
- 并查集的操作效率得到极大提升，使得集合树的深度不超过 $O(\alpha(n))$，其中 $\alpha(n)$ 是一个增长极其缓慢的函数。

希望这能帮助你更好地理解和记忆并查集的相关内容！
[Timestamp: 2026/02/25 21:21:13]